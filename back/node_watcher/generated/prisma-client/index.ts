// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql';
import {
  BaseClientOptions,
  makePrismaClientClass,
  Model,
} from 'prisma-client-lib';

import { typeDefs } from './prisma-schema';

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  blockNumber: (where?: BlockNumberWhereInput) => Promise<boolean>;
  heartBeat: (where?: HeartBeatWhereInput) => Promise<boolean>;
  nomination: (where?: NominationWhereInput) => Promise<boolean>;
  reward: (where?: RewardWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  slashing: (where?: SlashingWhereInput) => Promise<boolean>;
  stake: (where?: StakeWhereInput) => Promise<boolean>;
  totalIssuance: (where?: TotalIssuanceWhereInput) => Promise<boolean>;
  validation: (where?: ValidationWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  blockNumber: (
    where: BlockNumberWhereUniqueInput
  ) => BlockNumberNullablePromise;
  blockNumbers: (args?: {
    where?: BlockNumberWhereInput;
    orderBy?: BlockNumberOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BlockNumber>;
  blockNumbersConnection: (args?: {
    where?: BlockNumberWhereInput;
    orderBy?: BlockNumberOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => BlockNumberConnectionPromise;
  heartBeat: (where: HeartBeatWhereUniqueInput) => HeartBeatNullablePromise;
  heartBeats: (args?: {
    where?: HeartBeatWhereInput;
    orderBy?: HeartBeatOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HeartBeat>;
  heartBeatsConnection: (args?: {
    where?: HeartBeatWhereInput;
    orderBy?: HeartBeatOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => HeartBeatConnectionPromise;
  nomination: (where: NominationWhereUniqueInput) => NominationNullablePromise;
  nominations: (args?: {
    where?: NominationWhereInput;
    orderBy?: NominationOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Nomination>;
  nominationsConnection: (args?: {
    where?: NominationWhereInput;
    orderBy?: NominationOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => NominationConnectionPromise;
  reward: (where: RewardWhereUniqueInput) => RewardNullablePromise;
  rewards: (args?: {
    where?: RewardWhereInput;
    orderBy?: RewardOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reward>;
  rewardsConnection: (args?: {
    where?: RewardWhereInput;
    orderBy?: RewardOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => RewardConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionNullablePromise;
  sessions: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Session>;
  sessionsConnection: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => SessionConnectionPromise;
  slashing: (where: SlashingWhereUniqueInput) => SlashingNullablePromise;
  slashings: (args?: {
    where?: SlashingWhereInput;
    orderBy?: SlashingOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Slashing>;
  slashingsConnection: (args?: {
    where?: SlashingWhereInput;
    orderBy?: SlashingOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => SlashingConnectionPromise;
  stake: (where: StakeWhereUniqueInput) => StakeNullablePromise;
  stakes: (args?: {
    where?: StakeWhereInput;
    orderBy?: StakeOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Stake>;
  stakesConnection: (args?: {
    where?: StakeWhereInput;
    orderBy?: StakeOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => StakeConnectionPromise;
  totalIssuance: (
    where: TotalIssuanceWhereUniqueInput
  ) => TotalIssuanceNullablePromise;
  totalIssuances: (args?: {
    where?: TotalIssuanceWhereInput;
    orderBy?: TotalIssuanceOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TotalIssuance>;
  totalIssuancesConnection: (args?: {
    where?: TotalIssuanceWhereInput;
    orderBy?: TotalIssuanceOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => TotalIssuanceConnectionPromise;
  validation: (where: ValidationWhereUniqueInput) => ValidationNullablePromise;
  validations: (args?: {
    where?: ValidationWhereInput;
    orderBy?: ValidationOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Validation>;
  validationsConnection: (args?: {
    where?: ValidationWhereInput;
    orderBy?: ValidationOrderByInput;
    skip?: Int;
    after?: string;
    before?: string;
    first?: Int;
    last?: Int;
  }) => ValidationConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBlockNumber: (data: BlockNumberCreateInput) => BlockNumberPromise;
  updateBlockNumber: (args: {
    data: BlockNumberUpdateInput;
    where: BlockNumberWhereUniqueInput;
  }) => BlockNumberPromise;
  updateManyBlockNumbers: (args: {
    data: BlockNumberUpdateManyMutationInput;
    where?: BlockNumberWhereInput;
  }) => BatchPayloadPromise;
  upsertBlockNumber: (args: {
    where: BlockNumberWhereUniqueInput;
    create: BlockNumberCreateInput;
    update: BlockNumberUpdateInput;
  }) => BlockNumberPromise;
  deleteBlockNumber: (where: BlockNumberWhereUniqueInput) => BlockNumberPromise;
  deleteManyBlockNumbers: (
    where?: BlockNumberWhereInput
  ) => BatchPayloadPromise;
  createHeartBeat: (data: HeartBeatCreateInput) => HeartBeatPromise;
  updateHeartBeat: (args: {
    data: HeartBeatUpdateInput;
    where: HeartBeatWhereUniqueInput;
  }) => HeartBeatPromise;
  updateManyHeartBeats: (args: {
    data: HeartBeatUpdateManyMutationInput;
    where?: HeartBeatWhereInput;
  }) => BatchPayloadPromise;
  upsertHeartBeat: (args: {
    where: HeartBeatWhereUniqueInput;
    create: HeartBeatCreateInput;
    update: HeartBeatUpdateInput;
  }) => HeartBeatPromise;
  deleteHeartBeat: (where: HeartBeatWhereUniqueInput) => HeartBeatPromise;
  deleteManyHeartBeats: (where?: HeartBeatWhereInput) => BatchPayloadPromise;
  createNomination: (data: NominationCreateInput) => NominationPromise;
  updateNomination: (args: {
    data: NominationUpdateInput;
    where: NominationWhereUniqueInput;
  }) => NominationPromise;
  updateManyNominations: (args: {
    data: NominationUpdateManyMutationInput;
    where?: NominationWhereInput;
  }) => BatchPayloadPromise;
  upsertNomination: (args: {
    where: NominationWhereUniqueInput;
    create: NominationCreateInput;
    update: NominationUpdateInput;
  }) => NominationPromise;
  deleteNomination: (where: NominationWhereUniqueInput) => NominationPromise;
  deleteManyNominations: (where?: NominationWhereInput) => BatchPayloadPromise;
  createReward: (data: RewardCreateInput) => RewardPromise;
  updateReward: (args: {
    data: RewardUpdateInput;
    where: RewardWhereUniqueInput;
  }) => RewardPromise;
  updateManyRewards: (args: {
    data: RewardUpdateManyMutationInput;
    where?: RewardWhereInput;
  }) => BatchPayloadPromise;
  upsertReward: (args: {
    where: RewardWhereUniqueInput;
    create: RewardCreateInput;
    update: RewardUpdateInput;
  }) => RewardPromise;
  deleteReward: (where: RewardWhereUniqueInput) => RewardPromise;
  deleteManyRewards: (where?: RewardWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (args: {
    data: SessionUpdateInput;
    where: SessionWhereUniqueInput;
  }) => SessionPromise;
  upsertSession: (args: {
    where: SessionWhereUniqueInput;
    create: SessionCreateInput;
    update: SessionUpdateInput;
  }) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createSlashing: (data: SlashingCreateInput) => SlashingPromise;
  updateSlashing: (args: {
    data: SlashingUpdateInput;
    where: SlashingWhereUniqueInput;
  }) => SlashingPromise;
  updateManySlashings: (args: {
    data: SlashingUpdateManyMutationInput;
    where?: SlashingWhereInput;
  }) => BatchPayloadPromise;
  upsertSlashing: (args: {
    where: SlashingWhereUniqueInput;
    create: SlashingCreateInput;
    update: SlashingUpdateInput;
  }) => SlashingPromise;
  deleteSlashing: (where: SlashingWhereUniqueInput) => SlashingPromise;
  deleteManySlashings: (where?: SlashingWhereInput) => BatchPayloadPromise;
  createStake: (data: StakeCreateInput) => StakePromise;
  updateStake: (args: {
    data: StakeUpdateInput;
    where: StakeWhereUniqueInput;
  }) => StakePromise;
  updateManyStakes: (args: {
    data: StakeUpdateManyMutationInput;
    where?: StakeWhereInput;
  }) => BatchPayloadPromise;
  upsertStake: (args: {
    where: StakeWhereUniqueInput;
    create: StakeCreateInput;
    update: StakeUpdateInput;
  }) => StakePromise;
  deleteStake: (where: StakeWhereUniqueInput) => StakePromise;
  deleteManyStakes: (where?: StakeWhereInput) => BatchPayloadPromise;
  createTotalIssuance: (data: TotalIssuanceCreateInput) => TotalIssuancePromise;
  updateTotalIssuance: (args: {
    data: TotalIssuanceUpdateInput;
    where: TotalIssuanceWhereUniqueInput;
  }) => TotalIssuancePromise;
  updateManyTotalIssuances: (args: {
    data: TotalIssuanceUpdateManyMutationInput;
    where?: TotalIssuanceWhereInput;
  }) => BatchPayloadPromise;
  upsertTotalIssuance: (args: {
    where: TotalIssuanceWhereUniqueInput;
    create: TotalIssuanceCreateInput;
    update: TotalIssuanceUpdateInput;
  }) => TotalIssuancePromise;
  deleteTotalIssuance: (
    where: TotalIssuanceWhereUniqueInput
  ) => TotalIssuancePromise;
  deleteManyTotalIssuances: (
    where?: TotalIssuanceWhereInput
  ) => BatchPayloadPromise;
  createValidation: (data: ValidationCreateInput) => ValidationPromise;
  updateValidation: (args: {
    data: ValidationUpdateInput;
    where: ValidationWhereUniqueInput;
  }) => ValidationPromise;
  updateManyValidations: (args: {
    data: ValidationUpdateManyMutationInput;
    where?: ValidationWhereInput;
  }) => BatchPayloadPromise;
  upsertValidation: (args: {
    where: ValidationWhereUniqueInput;
    create: ValidationCreateInput;
    update: ValidationUpdateInput;
  }) => ValidationPromise;
  deleteValidation: (where: ValidationWhereUniqueInput) => ValidationPromise;
  deleteManyValidations: (where?: ValidationWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  blockNumber: (
    where?: BlockNumberSubscriptionWhereInput
  ) => BlockNumberSubscriptionPayloadSubscription;
  heartBeat: (
    where?: HeartBeatSubscriptionWhereInput
  ) => HeartBeatSubscriptionPayloadSubscription;
  nomination: (
    where?: NominationSubscriptionWhereInput
  ) => NominationSubscriptionPayloadSubscription;
  reward: (
    where?: RewardSubscriptionWhereInput
  ) => RewardSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  slashing: (
    where?: SlashingSubscriptionWhereInput
  ) => SlashingSubscriptionPayloadSubscription;
  stake: (
    where?: StakeSubscriptionWhereInput
  ) => StakeSubscriptionPayloadSubscription;
  totalIssuance: (
    where?: TotalIssuanceSubscriptionWhereInput
  ) => TotalIssuanceSubscriptionPayloadSubscription;
  validation: (
    where?: ValidationSubscriptionWhereInput
  ) => ValidationSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SlashingOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'reason_ASC'
  | 'reason_DESC'
  | 'amount_ASC'
  | 'amount_DESC';

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED';

export type HeartBeatOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'isOnline_ASC'
  | 'isOnline_DESC'
  | 'sender_ASC'
  | 'sender_DESC';

export type NominationOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'validatorController_ASC'
  | 'validatorController_DESC'
  | 'validatorStash_ASC'
  | 'validatorStash_DESC'
  | 'nominatorController_ASC'
  | 'nominatorController_DESC'
  | 'nominatorStash_ASC'
  | 'nominatorStash_DESC'
  | 'bonded_ASC'
  | 'bonded_DESC';

export type RewardOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'amount_ASC'
  | 'amount_DESC';

export type SessionOrderByInput = 'id_ASC' | 'id_DESC';

export type ValidationOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'validatorController_ASC'
  | 'validatorController_DESC'
  | 'validatorStash_ASC'
  | 'validatorStash_DESC'
  | 'validatorPreferences_ASC'
  | 'validatorPreferences_DESC';

export type BlockNumberOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'number_ASC'
  | 'number_DESC'
  | 'authoredBy_ASC'
  | 'authoredBy_DESC'
  | 'startDateTime_ASC'
  | 'startDateTime_DESC'
  | 'hash_ASC'
  | 'hash_DESC';

export type StakeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'totalStake_ASC'
  | 'totalStake_DESC';

export type TotalIssuanceOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'amount_ASC'
  | 'amount_DESC';

export interface SessionUpdateInput {
  start?: Maybe<BlockNumberUpdateOneRequiredInput>;
  end?: Maybe<BlockNumberUpdateOneRequiredInput>;
}

export interface HeartBeatCreateInput {
  id?: Maybe<ID_Input>;
  blockNumber: BlockNumberCreateOneInput;
  isOnline: boolean;
  sender: string;
}

export interface SlashingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<SlashingWhereInput>;
  AND?: Maybe<
    SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput
  >;
  OR?: Maybe<SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput>;
  NOT?: Maybe<
    SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput
  >;
}

export type BlockNumberWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  hash?: Maybe<string>;
}>;

export interface RewardCreaterecipientsInput {
  set?: Maybe<string[] | string>;
}

export type HeartBeatWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RewardCreateInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  authoredBlock: BlockNumberCreateOneInput;
  recipients?: Maybe<RewardCreaterecipientsInput>;
}

export interface HeartBeatWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockNumber?: Maybe<BlockNumberWhereInput>;
  isOnline?: Maybe<boolean>;
  isOnline_not?: Maybe<boolean>;
  sender?: Maybe<string>;
  sender_not?: Maybe<string>;
  sender_in?: Maybe<string[] | string>;
  sender_not_in?: Maybe<string[] | string>;
  sender_lt?: Maybe<string>;
  sender_lte?: Maybe<string>;
  sender_gt?: Maybe<string>;
  sender_gte?: Maybe<string>;
  sender_contains?: Maybe<string>;
  sender_not_contains?: Maybe<string>;
  sender_starts_with?: Maybe<string>;
  sender_not_starts_with?: Maybe<string>;
  sender_ends_with?: Maybe<string>;
  sender_not_ends_with?: Maybe<string>;
  AND?: Maybe<HeartBeatWhereInput[] | HeartBeatWhereInput>;
  OR?: Maybe<HeartBeatWhereInput[] | HeartBeatWhereInput>;
  NOT?: Maybe<HeartBeatWhereInput[] | HeartBeatWhereInput>;
}

export interface NominationUpdateManyMutationInput {
  validatorController?: Maybe<string>;
  validatorStash?: Maybe<string>;
  nominatorController?: Maybe<string>;
  nominatorStash?: Maybe<string>;
  bonded?: Maybe<Int>;
}

export interface ValidationUpdateManyMutationInput {
  validatorController?: Maybe<string>;
  validatorStash?: Maybe<string>;
  validatorPreferences?: Maybe<Int>;
}

export type StakeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ValidationCreateInput {
  id?: Maybe<ID_Input>;
  start: BlockNumberCreateOneInput;
  validatorController: string;
  validatorStash: string;
  validatorPreferences: Int;
}

export interface SessionUpsertNestedInput {
  update: SessionUpdateDataInput;
  create: SessionCreateInput;
}

export interface TotalIssuanceUpdateManyMutationInput {
  amount?: Maybe<Int>;
}

export interface StakeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockNumber?: Maybe<BlockNumberWhereInput>;
  totalStake?: Maybe<Int>;
  totalStake_not?: Maybe<Int>;
  totalStake_in?: Maybe<Int[] | Int>;
  totalStake_not_in?: Maybe<Int[] | Int>;
  totalStake_lt?: Maybe<Int>;
  totalStake_lte?: Maybe<Int>;
  totalStake_gt?: Maybe<Int>;
  totalStake_gte?: Maybe<Int>;
  AND?: Maybe<StakeWhereInput[] | StakeWhereInput>;
  OR?: Maybe<StakeWhereInput[] | StakeWhereInput>;
  NOT?: Maybe<StakeWhereInput[] | StakeWhereInput>;
}

export interface NominationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  validatorController?: Maybe<string>;
  validatorController_not?: Maybe<string>;
  validatorController_in?: Maybe<string[] | string>;
  validatorController_not_in?: Maybe<string[] | string>;
  validatorController_lt?: Maybe<string>;
  validatorController_lte?: Maybe<string>;
  validatorController_gt?: Maybe<string>;
  validatorController_gte?: Maybe<string>;
  validatorController_contains?: Maybe<string>;
  validatorController_not_contains?: Maybe<string>;
  validatorController_starts_with?: Maybe<string>;
  validatorController_not_starts_with?: Maybe<string>;
  validatorController_ends_with?: Maybe<string>;
  validatorController_not_ends_with?: Maybe<string>;
  validatorStash?: Maybe<string>;
  validatorStash_not?: Maybe<string>;
  validatorStash_in?: Maybe<string[] | string>;
  validatorStash_not_in?: Maybe<string[] | string>;
  validatorStash_lt?: Maybe<string>;
  validatorStash_lte?: Maybe<string>;
  validatorStash_gt?: Maybe<string>;
  validatorStash_gte?: Maybe<string>;
  validatorStash_contains?: Maybe<string>;
  validatorStash_not_contains?: Maybe<string>;
  validatorStash_starts_with?: Maybe<string>;
  validatorStash_not_starts_with?: Maybe<string>;
  validatorStash_ends_with?: Maybe<string>;
  validatorStash_not_ends_with?: Maybe<string>;
  nominatorController?: Maybe<string>;
  nominatorController_not?: Maybe<string>;
  nominatorController_in?: Maybe<string[] | string>;
  nominatorController_not_in?: Maybe<string[] | string>;
  nominatorController_lt?: Maybe<string>;
  nominatorController_lte?: Maybe<string>;
  nominatorController_gt?: Maybe<string>;
  nominatorController_gte?: Maybe<string>;
  nominatorController_contains?: Maybe<string>;
  nominatorController_not_contains?: Maybe<string>;
  nominatorController_starts_with?: Maybe<string>;
  nominatorController_not_starts_with?: Maybe<string>;
  nominatorController_ends_with?: Maybe<string>;
  nominatorController_not_ends_with?: Maybe<string>;
  nominatorStash?: Maybe<string>;
  nominatorStash_not?: Maybe<string>;
  nominatorStash_in?: Maybe<string[] | string>;
  nominatorStash_not_in?: Maybe<string[] | string>;
  nominatorStash_lt?: Maybe<string>;
  nominatorStash_lte?: Maybe<string>;
  nominatorStash_gt?: Maybe<string>;
  nominatorStash_gte?: Maybe<string>;
  nominatorStash_contains?: Maybe<string>;
  nominatorStash_not_contains?: Maybe<string>;
  nominatorStash_starts_with?: Maybe<string>;
  nominatorStash_not_starts_with?: Maybe<string>;
  nominatorStash_ends_with?: Maybe<string>;
  nominatorStash_not_ends_with?: Maybe<string>;
  session?: Maybe<SessionWhereInput>;
  bonded?: Maybe<Int>;
  bonded_not?: Maybe<Int>;
  bonded_in?: Maybe<Int[] | Int>;
  bonded_not_in?: Maybe<Int[] | Int>;
  bonded_lt?: Maybe<Int>;
  bonded_lte?: Maybe<Int>;
  bonded_gt?: Maybe<Int>;
  bonded_gte?: Maybe<Int>;
  AND?: Maybe<NominationWhereInput[] | NominationWhereInput>;
  OR?: Maybe<NominationWhereInput[] | NominationWhereInput>;
  NOT?: Maybe<NominationWhereInput[] | NominationWhereInput>;
}

export interface BlockNumberWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  authoredBy?: Maybe<string>;
  authoredBy_not?: Maybe<string>;
  authoredBy_in?: Maybe<string[] | string>;
  authoredBy_not_in?: Maybe<string[] | string>;
  authoredBy_lt?: Maybe<string>;
  authoredBy_lte?: Maybe<string>;
  authoredBy_gt?: Maybe<string>;
  authoredBy_gte?: Maybe<string>;
  authoredBy_contains?: Maybe<string>;
  authoredBy_not_contains?: Maybe<string>;
  authoredBy_starts_with?: Maybe<string>;
  authoredBy_not_starts_with?: Maybe<string>;
  authoredBy_ends_with?: Maybe<string>;
  authoredBy_not_ends_with?: Maybe<string>;
  startDateTime?: Maybe<DateTimeInput>;
  startDateTime_not?: Maybe<DateTimeInput>;
  startDateTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDateTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDateTime_lt?: Maybe<DateTimeInput>;
  startDateTime_lte?: Maybe<DateTimeInput>;
  startDateTime_gt?: Maybe<DateTimeInput>;
  startDateTime_gte?: Maybe<DateTimeInput>;
  hash?: Maybe<string>;
  hash_not?: Maybe<string>;
  hash_in?: Maybe<string[] | string>;
  hash_not_in?: Maybe<string[] | string>;
  hash_lt?: Maybe<string>;
  hash_lte?: Maybe<string>;
  hash_gt?: Maybe<string>;
  hash_gte?: Maybe<string>;
  hash_contains?: Maybe<string>;
  hash_not_contains?: Maybe<string>;
  hash_starts_with?: Maybe<string>;
  hash_not_starts_with?: Maybe<string>;
  hash_ends_with?: Maybe<string>;
  hash_not_ends_with?: Maybe<string>;
  AND?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
  OR?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
  NOT?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
}

export interface NominationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<NominationWhereInput>;
  AND?: Maybe<
    NominationSubscriptionWhereInput[] | NominationSubscriptionWhereInput
  >;
  OR?: Maybe<
    NominationSubscriptionWhereInput[] | NominationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NominationSubscriptionWhereInput[] | NominationSubscriptionWhereInput
  >;
}

export interface SessionUpdateDataInput {
  start?: Maybe<BlockNumberUpdateOneRequiredInput>;
  end?: Maybe<BlockNumberUpdateOneRequiredInput>;
}

export interface StakeUpdateManyMutationInput {
  totalStake?: Maybe<Int>;
}

export interface SessionUpdateOneRequiredInput {
  create?: Maybe<SessionCreateInput>;
  update?: Maybe<SessionUpdateDataInput>;
  upsert?: Maybe<SessionUpsertNestedInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export type RewardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NominationUpdateInput {
  validatorController?: Maybe<string>;
  validatorStash?: Maybe<string>;
  nominatorController?: Maybe<string>;
  nominatorStash?: Maybe<string>;
  session?: Maybe<SessionUpdateOneRequiredInput>;
  bonded?: Maybe<Int>;
}

export interface RewardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  authoredBlock?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<RewardWhereInput[] | RewardWhereInput>;
  OR?: Maybe<RewardWhereInput[] | RewardWhereInput>;
  NOT?: Maybe<RewardWhereInput[] | RewardWhereInput>;
}

export type TotalIssuanceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SlashingUpdateManyMutationInput {
  reason?: Maybe<string>;
  amount?: Maybe<Int>;
}

export interface SessionCreateInput {
  id?: Maybe<ID_Input>;
  start: BlockNumberCreateOneInput;
  end: BlockNumberCreateOneInput;
}

export interface SlashingCreateInput {
  id?: Maybe<ID_Input>;
  blockNumber: BlockNumberCreateOneInput;
  reason: string;
  amount: Int;
}

export interface TotalIssuanceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
  OR?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
  NOT?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<SessionWhereInput>;
  AND?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  OR?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  NOT?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
}

export interface StakeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<StakeWhereInput>;
  AND?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
  OR?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
  NOT?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
}

export interface RewardUpdateManyMutationInput {
  amount?: Maybe<Int>;
  recipients?: Maybe<RewardUpdaterecipientsInput>;
}

export interface SessionCreateOneInput {
  create?: Maybe<SessionCreateInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export type SlashingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NominationCreateInput {
  id?: Maybe<ID_Input>;
  validatorController: string;
  validatorStash: string;
  nominatorController: string;
  nominatorStash: string;
  session: SessionCreateOneInput;
  bonded: Int;
}

export interface SlashingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockNumber?: Maybe<BlockNumberWhereInput>;
  reason?: Maybe<string>;
  reason_not?: Maybe<string>;
  reason_in?: Maybe<string[] | string>;
  reason_not_in?: Maybe<string[] | string>;
  reason_lt?: Maybe<string>;
  reason_lte?: Maybe<string>;
  reason_gt?: Maybe<string>;
  reason_gte?: Maybe<string>;
  reason_contains?: Maybe<string>;
  reason_not_contains?: Maybe<string>;
  reason_starts_with?: Maybe<string>;
  reason_not_starts_with?: Maybe<string>;
  reason_ends_with?: Maybe<string>;
  reason_not_ends_with?: Maybe<string>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
  OR?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
  NOT?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
}

export interface HeartBeatUpdateManyMutationInput {
  isOnline?: Maybe<boolean>;
  sender?: Maybe<string>;
}

export interface HeartBeatSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<HeartBeatWhereInput>;
  AND?: Maybe<
    HeartBeatSubscriptionWhereInput[] | HeartBeatSubscriptionWhereInput
  >;
  OR?: Maybe<
    HeartBeatSubscriptionWhereInput[] | HeartBeatSubscriptionWhereInput
  >;
  NOT?: Maybe<
    HeartBeatSubscriptionWhereInput[] | HeartBeatSubscriptionWhereInput
  >;
}

export type ValidationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NominationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BlockNumberUpsertNestedInput {
  update: BlockNumberUpdateDataInput;
  create: BlockNumberCreateInput;
}

export interface SessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  start?: Maybe<BlockNumberWhereInput>;
  end?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  OR?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  NOT?: Maybe<SessionWhereInput[] | SessionWhereInput>;
}

export interface ValidationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  start?: Maybe<BlockNumberWhereInput>;
  validatorController?: Maybe<string>;
  validatorController_not?: Maybe<string>;
  validatorController_in?: Maybe<string[] | string>;
  validatorController_not_in?: Maybe<string[] | string>;
  validatorController_lt?: Maybe<string>;
  validatorController_lte?: Maybe<string>;
  validatorController_gt?: Maybe<string>;
  validatorController_gte?: Maybe<string>;
  validatorController_contains?: Maybe<string>;
  validatorController_not_contains?: Maybe<string>;
  validatorController_starts_with?: Maybe<string>;
  validatorController_not_starts_with?: Maybe<string>;
  validatorController_ends_with?: Maybe<string>;
  validatorController_not_ends_with?: Maybe<string>;
  validatorStash?: Maybe<string>;
  validatorStash_not?: Maybe<string>;
  validatorStash_in?: Maybe<string[] | string>;
  validatorStash_not_in?: Maybe<string[] | string>;
  validatorStash_lt?: Maybe<string>;
  validatorStash_lte?: Maybe<string>;
  validatorStash_gt?: Maybe<string>;
  validatorStash_gte?: Maybe<string>;
  validatorStash_contains?: Maybe<string>;
  validatorStash_not_contains?: Maybe<string>;
  validatorStash_starts_with?: Maybe<string>;
  validatorStash_not_starts_with?: Maybe<string>;
  validatorStash_ends_with?: Maybe<string>;
  validatorStash_not_ends_with?: Maybe<string>;
  validatorPreferences?: Maybe<Int>;
  validatorPreferences_not?: Maybe<Int>;
  validatorPreferences_in?: Maybe<Int[] | Int>;
  validatorPreferences_not_in?: Maybe<Int[] | Int>;
  validatorPreferences_lt?: Maybe<Int>;
  validatorPreferences_lte?: Maybe<Int>;
  validatorPreferences_gt?: Maybe<Int>;
  validatorPreferences_gte?: Maybe<Int>;
  AND?: Maybe<ValidationWhereInput[] | ValidationWhereInput>;
  OR?: Maybe<ValidationWhereInput[] | ValidationWhereInput>;
  NOT?: Maybe<ValidationWhereInput[] | ValidationWhereInput>;
}

export interface StakeUpdateInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  totalStake?: Maybe<Int>;
}

export interface TotalIssuanceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<TotalIssuanceWhereInput>;
  AND?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
  OR?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
}

export interface RewardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<RewardWhereInput>;
  AND?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
  OR?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
  NOT?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
}

export interface BlockNumberUpdateDataInput {
  number?: Maybe<Int>;
  authoredBy?: Maybe<string>;
  startDateTime?: Maybe<DateTimeInput>;
  hash?: Maybe<string>;
}

export type SessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BlockNumberUpdateOneRequiredInput {
  create?: Maybe<BlockNumberCreateInput>;
  update?: Maybe<BlockNumberUpdateDataInput>;
  upsert?: Maybe<BlockNumberUpsertNestedInput>;
  connect?: Maybe<BlockNumberWhereUniqueInput>;
}

export interface RewardUpdaterecipientsInput {
  set?: Maybe<string[] | string>;
}

export interface HeartBeatUpdateInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  isOnline?: Maybe<boolean>;
  sender?: Maybe<string>;
}

export interface BlockNumberSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
  OR?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
}

export interface TotalIssuanceUpdateInput {
  amount?: Maybe<Int>;
}

export interface StakeCreateInput {
  id?: Maybe<ID_Input>;
  blockNumber: BlockNumberCreateOneInput;
  totalStake: Int;
}

export interface BlockNumberCreateOneInput {
  create?: Maybe<BlockNumberCreateInput>;
  connect?: Maybe<BlockNumberWhereUniqueInput>;
}

export interface BlockNumberUpdateManyMutationInput {
  number?: Maybe<Int>;
  authoredBy?: Maybe<string>;
  startDateTime?: Maybe<DateTimeInput>;
  hash?: Maybe<string>;
}

export interface BlockNumberUpdateInput {
  number?: Maybe<Int>;
  authoredBy?: Maybe<string>;
  startDateTime?: Maybe<DateTimeInput>;
  hash?: Maybe<string>;
}

export interface BlockNumberCreateInput {
  id?: Maybe<Int>;
  number: Int;
  authoredBy: string;
  startDateTime: DateTimeInput;
  hash: string;
}

export interface SlashingUpdateInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  reason?: Maybe<string>;
  amount?: Maybe<Int>;
}

export interface TotalIssuanceCreateInput {
  id?: Maybe<ID_Input>;
  amount: Int;
}

export interface ValidationUpdateInput {
  start?: Maybe<BlockNumberUpdateOneRequiredInput>;
  validatorController?: Maybe<string>;
  validatorStash?: Maybe<string>;
  validatorPreferences?: Maybe<Int>;
}

export interface RewardUpdateInput {
  amount?: Maybe<Int>;
  authoredBlock?: Maybe<BlockNumberUpdateOneRequiredInput>;
  recipients?: Maybe<RewardUpdaterecipientsInput>;
}

export interface ValidationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<string>;
  updatedFields_contains_every?: Maybe<string[] | string>;
  updatedFields_contains_some?: Maybe<string[] | string>;
  node?: Maybe<ValidationWhereInput>;
  AND?: Maybe<
    ValidationSubscriptionWhereInput[] | ValidationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ValidationSubscriptionWhereInput[] | ValidationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ValidationSubscriptionWhereInput[] | ValidationSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AggregateValidation {
  count: Int;
}

export interface AggregateValidationPromise
  extends Promise<AggregateValidation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValidationSubscription
  extends Promise<AsyncIterator<AggregateValidation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateHeartBeat {
  count: Int;
}

export interface AggregateHeartBeatPromise
  extends Promise<AggregateHeartBeat>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHeartBeatSubscription
  extends Promise<AsyncIterator<AggregateHeartBeat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValidationPreviousValues {
  id: ID_Output;
  validatorController: string;
  validatorStash: string;
  validatorPreferences: Int;
}

export interface ValidationPreviousValuesPromise
  extends Promise<ValidationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  validatorController: () => Promise<string>;
  validatorStash: () => Promise<string>;
  validatorPreferences: () => Promise<Int>;
}

export interface ValidationPreviousValuesSubscription
  extends Promise<AsyncIterator<ValidationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  validatorController: () => Promise<AsyncIterator<string>>;
  validatorStash: () => Promise<AsyncIterator<string>>;
  validatorPreferences: () => Promise<AsyncIterator<Int>>;
}

export interface Nomination {
  id: ID_Output;
  validatorController: string;
  validatorStash: string;
  nominatorController: string;
  nominatorStash: string;
  bonded: Int;
}

export interface NominationPromise extends Promise<Nomination>, Fragmentable {
  id: () => Promise<ID_Output>;
  validatorController: () => Promise<string>;
  validatorStash: () => Promise<string>;
  nominatorController: () => Promise<string>;
  nominatorStash: () => Promise<string>;
  session: <T = SessionPromise>() => T;
  bonded: () => Promise<Int>;
}

export interface NominationSubscription
  extends Promise<AsyncIterator<Nomination>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  validatorController: () => Promise<AsyncIterator<string>>;
  validatorStash: () => Promise<AsyncIterator<string>>;
  nominatorController: () => Promise<AsyncIterator<string>>;
  nominatorStash: () => Promise<AsyncIterator<string>>;
  session: <T = SessionSubscription>() => T;
  bonded: () => Promise<AsyncIterator<Int>>;
}

export interface NominationNullablePromise
  extends Promise<Nomination | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  validatorController: () => Promise<string>;
  validatorStash: () => Promise<string>;
  nominatorController: () => Promise<string>;
  nominatorStash: () => Promise<string>;
  session: <T = SessionPromise>() => T;
  bonded: () => Promise<Int>;
}

export interface BlockNumber {
  id: Int;
  number: Int;
  authoredBy: string;
  startDateTime: DateTimeOutput;
  hash: string;
}

export interface BlockNumberPromise extends Promise<BlockNumber>, Fragmentable {
  id: () => Promise<Int>;
  number: () => Promise<Int>;
  authoredBy: () => Promise<string>;
  startDateTime: () => Promise<DateTimeOutput>;
  hash: () => Promise<string>;
}

export interface BlockNumberSubscription
  extends Promise<AsyncIterator<BlockNumber>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  number: () => Promise<AsyncIterator<Int>>;
  authoredBy: () => Promise<AsyncIterator<string>>;
  startDateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  hash: () => Promise<AsyncIterator<string>>;
}

export interface BlockNumberNullablePromise
  extends Promise<BlockNumber | null>,
    Fragmentable {
  id: () => Promise<Int>;
  number: () => Promise<Int>;
  authoredBy: () => Promise<string>;
  startDateTime: () => Promise<DateTimeOutput>;
  hash: () => Promise<string>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface HeartBeatEdge {
  node: HeartBeat;
  cursor: string;
}

export interface HeartBeatEdgePromise
  extends Promise<HeartBeatEdge>,
    Fragmentable {
  node: <T = HeartBeatPromise>() => T;
  cursor: () => Promise<string>;
}

export interface HeartBeatEdgeSubscription
  extends Promise<AsyncIterator<HeartBeatEdge>>,
    Fragmentable {
  node: <T = HeartBeatSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export interface ValidationEdge {
  node: Validation;
  cursor: string;
}

export interface ValidationEdgePromise
  extends Promise<ValidationEdge>,
    Fragmentable {
  node: <T = ValidationPromise>() => T;
  cursor: () => Promise<string>;
}

export interface ValidationEdgeSubscription
  extends Promise<AsyncIterator<ValidationEdge>>,
    Fragmentable {
  node: <T = ValidationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export interface Validation {
  id: ID_Output;
  validatorController: string;
  validatorStash: string;
  validatorPreferences: Int;
}

export interface ValidationPromise extends Promise<Validation>, Fragmentable {
  id: () => Promise<ID_Output>;
  start: <T = BlockNumberPromise>() => T;
  validatorController: () => Promise<string>;
  validatorStash: () => Promise<string>;
  validatorPreferences: () => Promise<Int>;
}

export interface ValidationSubscription
  extends Promise<AsyncIterator<Validation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: <T = BlockNumberSubscription>() => T;
  validatorController: () => Promise<AsyncIterator<string>>;
  validatorStash: () => Promise<AsyncIterator<string>>;
  validatorPreferences: () => Promise<AsyncIterator<Int>>;
}

export interface ValidationNullablePromise
  extends Promise<Validation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: <T = BlockNumberPromise>() => T;
  validatorController: () => Promise<string>;
  validatorStash: () => Promise<string>;
  validatorPreferences: () => Promise<Int>;
}

export interface HeartBeatConnection {
  pageInfo: PageInfo;
  edges: HeartBeatEdge[];
}

export interface HeartBeatConnectionPromise
  extends Promise<HeartBeatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HeartBeatEdge>>() => T;
  aggregate: <T = AggregateHeartBeatPromise>() => T;
}

export interface HeartBeatConnectionSubscription
  extends Promise<AsyncIterator<HeartBeatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HeartBeatEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHeartBeatSubscription>() => T;
}

export interface TotalIssuanceEdge {
  node: TotalIssuance;
  cursor: string;
}

export interface TotalIssuanceEdgePromise
  extends Promise<TotalIssuanceEdge>,
    Fragmentable {
  node: <T = TotalIssuancePromise>() => T;
  cursor: () => Promise<string>;
}

export interface TotalIssuanceEdgeSubscription
  extends Promise<AsyncIterator<TotalIssuanceEdge>>,
    Fragmentable {
  node: <T = TotalIssuanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export interface HeartBeat {
  id: ID_Output;
  isOnline: boolean;
  sender: string;
}

export interface HeartBeatPromise extends Promise<HeartBeat>, Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  isOnline: () => Promise<boolean>;
  sender: () => Promise<string>;
}

export interface HeartBeatSubscription
  extends Promise<AsyncIterator<HeartBeat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockNumber: <T = BlockNumberSubscription>() => T;
  isOnline: () => Promise<AsyncIterator<boolean>>;
  sender: () => Promise<AsyncIterator<string>>;
}

export interface HeartBeatNullablePromise
  extends Promise<HeartBeat | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  isOnline: () => Promise<boolean>;
  sender: () => Promise<string>;
}

export interface TotalIssuance {
  id: ID_Output;
  amount: Int;
}

export interface TotalIssuancePromise
  extends Promise<TotalIssuance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
}

export interface TotalIssuanceSubscription
  extends Promise<AsyncIterator<TotalIssuance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface TotalIssuanceNullablePromise
  extends Promise<TotalIssuance | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
}

export interface ValidationSubscriptionPayload {
  mutation: MutationType;
  node: Validation;
  updatedFields: string[];
  previousValues: ValidationPreviousValues;
}

export interface ValidationSubscriptionPayloadPromise
  extends Promise<ValidationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValidationPromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = ValidationPreviousValuesPromise>() => T;
}

export interface ValidationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValidationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValidationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = ValidationPreviousValuesSubscription>() => T;
}

export interface StakeEdge {
  node: Stake;
  cursor: string;
}

export interface StakeEdgePromise extends Promise<StakeEdge>, Fragmentable {
  node: <T = StakePromise>() => T;
  cursor: () => Promise<string>;
}

export interface StakeEdgeSubscription
  extends Promise<AsyncIterator<StakeEdge>>,
    Fragmentable {
  node: <T = StakeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export interface BlockNumberSubscriptionPayload {
  mutation: MutationType;
  node: BlockNumber;
  updatedFields: string[];
  previousValues: BlockNumberPreviousValues;
}

export interface BlockNumberSubscriptionPayloadPromise
  extends Promise<BlockNumberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlockNumberPromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = BlockNumberPreviousValuesPromise>() => T;
}

export interface BlockNumberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlockNumberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlockNumberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = BlockNumberPreviousValuesSubscription>() => T;
}

export interface Stake {
  id: ID_Output;
  totalStake: Int;
}

export interface StakePromise extends Promise<Stake>, Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  totalStake: () => Promise<Int>;
}

export interface StakeSubscription
  extends Promise<AsyncIterator<Stake>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockNumber: <T = BlockNumberSubscription>() => T;
  totalStake: () => Promise<AsyncIterator<Int>>;
}

export interface StakeNullablePromise
  extends Promise<Stake | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  totalStake: () => Promise<Int>;
}

export interface BlockNumberPreviousValues {
  id: Int;
  number: Int;
  authoredBy: string;
  startDateTime: DateTimeOutput;
  hash: string;
}

export interface BlockNumberPreviousValuesPromise
  extends Promise<BlockNumberPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  number: () => Promise<Int>;
  authoredBy: () => Promise<string>;
  startDateTime: () => Promise<DateTimeOutput>;
  hash: () => Promise<string>;
}

export interface BlockNumberPreviousValuesSubscription
  extends Promise<AsyncIterator<BlockNumberPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  number: () => Promise<AsyncIterator<Int>>;
  authoredBy: () => Promise<AsyncIterator<string>>;
  startDateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  hash: () => Promise<AsyncIterator<string>>;
}

export interface SlashingEdge {
  node: Slashing;
  cursor: string;
}

export interface SlashingEdgePromise
  extends Promise<SlashingEdge>,
    Fragmentable {
  node: <T = SlashingPromise>() => T;
  cursor: () => Promise<string>;
}

export interface SlashingEdgeSubscription
  extends Promise<AsyncIterator<SlashingEdge>>,
    Fragmentable {
  node: <T = SlashingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export interface AggregateBlockNumber {
  count: Int;
}

export interface AggregateBlockNumberPromise
  extends Promise<AggregateBlockNumber>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlockNumberSubscription
  extends Promise<AsyncIterator<AggregateBlockNumber>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Slashing {
  id: ID_Output;
  reason: string;
  amount: Int;
}

export interface SlashingPromise extends Promise<Slashing>, Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  reason: () => Promise<string>;
  amount: () => Promise<Int>;
}

export interface SlashingSubscription
  extends Promise<AsyncIterator<Slashing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockNumber: <T = BlockNumberSubscription>() => T;
  reason: () => Promise<AsyncIterator<string>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface SlashingNullablePromise
  extends Promise<Slashing | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  reason: () => Promise<string>;
  amount: () => Promise<Int>;
}

export interface HeartBeatSubscriptionPayload {
  mutation: MutationType;
  node: HeartBeat;
  updatedFields: string[];
  previousValues: HeartBeatPreviousValues;
}

export interface HeartBeatSubscriptionPayloadPromise
  extends Promise<HeartBeatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HeartBeatPromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = HeartBeatPreviousValuesPromise>() => T;
}

export interface HeartBeatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HeartBeatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HeartBeatSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = HeartBeatPreviousValuesSubscription>() => T;
}

export interface SessionEdge {
  node: Session;
  cursor: string;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<string>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export interface HeartBeatPreviousValues {
  id: ID_Output;
  isOnline: boolean;
  sender: string;
}

export interface HeartBeatPreviousValuesPromise
  extends Promise<HeartBeatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isOnline: () => Promise<boolean>;
  sender: () => Promise<string>;
}

export interface HeartBeatPreviousValuesSubscription
  extends Promise<AsyncIterator<HeartBeatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isOnline: () => Promise<AsyncIterator<boolean>>;
  sender: () => Promise<AsyncIterator<string>>;
}

export interface AggregateReward {
  count: Int;
}

export interface AggregateRewardPromise
  extends Promise<AggregateReward>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRewardSubscription
  extends Promise<AsyncIterator<AggregateReward>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockNumberEdge {
  node: BlockNumber;
  cursor: string;
}

export interface BlockNumberEdgePromise
  extends Promise<BlockNumberEdge>,
    Fragmentable {
  node: <T = BlockNumberPromise>() => T;
  cursor: () => Promise<string>;
}

export interface BlockNumberEdgeSubscription
  extends Promise<AsyncIterator<BlockNumberEdge>>,
    Fragmentable {
  node: <T = BlockNumberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export interface RewardConnection {
  pageInfo: PageInfo;
  edges: RewardEdge[];
}

export interface RewardConnectionPromise
  extends Promise<RewardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RewardEdge>>() => T;
  aggregate: <T = AggregateRewardPromise>() => T;
}

export interface RewardConnectionSubscription
  extends Promise<AsyncIterator<RewardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RewardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRewardSubscription>() => T;
}

export interface NominationSubscriptionPayload {
  mutation: MutationType;
  node: Nomination;
  updatedFields: string[];
  previousValues: NominationPreviousValues;
}

export interface NominationSubscriptionPayloadPromise
  extends Promise<NominationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NominationPromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = NominationPreviousValuesPromise>() => T;
}

export interface NominationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NominationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NominationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = NominationPreviousValuesSubscription>() => T;
}

export interface AggregateNomination {
  count: Int;
}

export interface AggregateNominationPromise
  extends Promise<AggregateNomination>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNominationSubscription
  extends Promise<AsyncIterator<AggregateNomination>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NominationPreviousValues {
  id: ID_Output;
  validatorController: string;
  validatorStash: string;
  nominatorController: string;
  nominatorStash: string;
  bonded: Int;
}

export interface NominationPreviousValuesPromise
  extends Promise<NominationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  validatorController: () => Promise<string>;
  validatorStash: () => Promise<string>;
  nominatorController: () => Promise<string>;
  nominatorStash: () => Promise<string>;
  bonded: () => Promise<Int>;
}

export interface NominationPreviousValuesSubscription
  extends Promise<AsyncIterator<NominationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  validatorController: () => Promise<AsyncIterator<string>>;
  validatorStash: () => Promise<AsyncIterator<string>>;
  nominatorController: () => Promise<AsyncIterator<string>>;
  nominatorStash: () => Promise<AsyncIterator<string>>;
  bonded: () => Promise<AsyncIterator<Int>>;
}

export interface NominationConnection {
  pageInfo: PageInfo;
  edges: NominationEdge[];
}

export interface NominationConnectionPromise
  extends Promise<NominationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NominationEdge>>() => T;
  aggregate: <T = AggregateNominationPromise>() => T;
}

export interface NominationConnectionSubscription
  extends Promise<AsyncIterator<NominationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NominationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNominationSubscription>() => T;
}

export interface TotalIssuancePreviousValues {
  id: ID_Output;
  amount: Int;
}

export interface TotalIssuancePreviousValuesPromise
  extends Promise<TotalIssuancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
}

export interface TotalIssuancePreviousValuesSubscription
  extends Promise<AsyncIterator<TotalIssuancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface ValidationConnection {
  pageInfo: PageInfo;
  edges: ValidationEdge[];
}

export interface ValidationConnectionPromise
  extends Promise<ValidationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValidationEdge>>() => T;
  aggregate: <T = AggregateValidationPromise>() => T;
}

export interface ValidationConnectionSubscription
  extends Promise<AsyncIterator<ValidationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ValidationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateValidationSubscription>() => T;
}

export interface RewardSubscriptionPayload {
  mutation: MutationType;
  node: Reward;
  updatedFields: string[];
  previousValues: RewardPreviousValues;
}

export interface RewardSubscriptionPayloadPromise
  extends Promise<RewardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RewardPromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = RewardPreviousValuesPromise>() => T;
}

export interface RewardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RewardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RewardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = RewardPreviousValuesSubscription>() => T;
}

export interface TotalIssuanceConnection {
  pageInfo: PageInfo;
  edges: TotalIssuanceEdge[];
}

export interface TotalIssuanceConnectionPromise
  extends Promise<TotalIssuanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TotalIssuanceEdge>>() => T;
  aggregate: <T = AggregateTotalIssuancePromise>() => T;
}

export interface TotalIssuanceConnectionSubscription
  extends Promise<AsyncIterator<TotalIssuanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TotalIssuanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTotalIssuanceSubscription>() => T;
}

export interface RewardPreviousValues {
  id: ID_Output;
  amount: Int;
  recipients: string[];
}

export interface RewardPreviousValuesPromise
  extends Promise<RewardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
  recipients: () => Promise<string[]>;
}

export interface RewardPreviousValuesSubscription
  extends Promise<AsyncIterator<RewardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Int>>;
  recipients: () => Promise<AsyncIterator<string[]>>;
}

export interface StakeConnection {
  pageInfo: PageInfo;
  edges: StakeEdge[];
}

export interface StakeConnectionPromise
  extends Promise<StakeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StakeEdge>>() => T;
  aggregate: <T = AggregateStakePromise>() => T;
}

export interface StakeConnectionSubscription
  extends Promise<AsyncIterator<StakeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StakeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStakeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor?: string;
  endCursor?: string;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<boolean>;
  hasPreviousPage: () => Promise<boolean>;
  startCursor: () => Promise<string>;
  endCursor: () => Promise<string>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<boolean>>;
  startCursor: () => Promise<AsyncIterator<string>>;
  endCursor: () => Promise<AsyncIterator<string>>;
}

export interface SlashingConnection {
  pageInfo: PageInfo;
  edges: SlashingEdge[];
}

export interface SlashingConnectionPromise
  extends Promise<SlashingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SlashingEdge>>() => T;
  aggregate: <T = AggregateSlashingPromise>() => T;
}

export interface SlashingConnectionSubscription
  extends Promise<AsyncIterator<SlashingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SlashingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSlashingSubscription>() => T;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: string[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface SessionPreviousValues {
  id: ID_Output;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Reward {
  id: ID_Output;
  amount: Int;
  recipients: string[];
}

export interface RewardPromise extends Promise<Reward>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
  authoredBlock: <T = BlockNumberPromise>() => T;
  recipients: () => Promise<string[]>;
}

export interface RewardSubscription
  extends Promise<AsyncIterator<Reward>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Int>>;
  authoredBlock: <T = BlockNumberSubscription>() => T;
  recipients: () => Promise<AsyncIterator<string[]>>;
}

export interface RewardNullablePromise
  extends Promise<Reward | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
  authoredBlock: <T = BlockNumberPromise>() => T;
  recipients: () => Promise<string[]>;
}

export interface BlockNumberConnection {
  pageInfo: PageInfo;
  edges: BlockNumberEdge[];
}

export interface BlockNumberConnectionPromise
  extends Promise<BlockNumberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlockNumberEdge>>() => T;
  aggregate: <T = AggregateBlockNumberPromise>() => T;
}

export interface BlockNumberConnectionSubscription
  extends Promise<AsyncIterator<BlockNumberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlockNumberEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlockNumberSubscription>() => T;
}

export interface Session {
  id: ID_Output;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  id: () => Promise<ID_Output>;
  start: <T = BlockNumberPromise>() => T;
  end: <T = BlockNumberPromise>() => T;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: <T = BlockNumberSubscription>() => T;
  end: <T = BlockNumberSubscription>() => T;
}

export interface SessionNullablePromise
  extends Promise<Session | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: <T = BlockNumberPromise>() => T;
  end: <T = BlockNumberPromise>() => T;
}

export interface SlashingSubscriptionPayload {
  mutation: MutationType;
  node: Slashing;
  updatedFields: string[];
  previousValues: SlashingPreviousValues;
}

export interface SlashingSubscriptionPayloadPromise
  extends Promise<SlashingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SlashingPromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = SlashingPreviousValuesPromise>() => T;
}

export interface SlashingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SlashingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SlashingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = SlashingPreviousValuesSubscription>() => T;
}

export interface AggregateStake {
  count: Int;
}

export interface AggregateStakePromise
  extends Promise<AggregateStake>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStakeSubscription
  extends Promise<AsyncIterator<AggregateStake>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StakePreviousValues {
  id: ID_Output;
  totalStake: Int;
}

export interface StakePreviousValuesPromise
  extends Promise<StakePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  totalStake: () => Promise<Int>;
}

export interface StakePreviousValuesSubscription
  extends Promise<AsyncIterator<StakePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  totalStake: () => Promise<AsyncIterator<Int>>;
}

export interface StakeSubscriptionPayload {
  mutation: MutationType;
  node: Stake;
  updatedFields: string[];
  previousValues: StakePreviousValues;
}

export interface StakeSubscriptionPayloadPromise
  extends Promise<StakeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StakePromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = StakePreviousValuesPromise>() => T;
}

export interface StakeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StakeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StakeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = StakePreviousValuesSubscription>() => T;
}

export interface TotalIssuanceSubscriptionPayload {
  mutation: MutationType;
  node: TotalIssuance;
  updatedFields: string[];
  previousValues: TotalIssuancePreviousValues;
}

export interface TotalIssuanceSubscriptionPayloadPromise
  extends Promise<TotalIssuanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TotalIssuancePromise>() => T;
  updatedFields: () => Promise<string[]>;
  previousValues: <T = TotalIssuancePreviousValuesPromise>() => T;
}

export interface TotalIssuanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TotalIssuanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TotalIssuanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<string[]>>;
  previousValues: <T = TotalIssuancePreviousValuesSubscription>() => T;
}

export interface SlashingPreviousValues {
  id: ID_Output;
  reason: string;
  amount: Int;
}

export interface SlashingPreviousValuesPromise
  extends Promise<SlashingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<string>;
  amount: () => Promise<Int>;
}

export interface SlashingPreviousValuesSubscription
  extends Promise<AsyncIterator<SlashingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<string>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface RewardEdge {
  node: Reward;
  cursor: string;
}

export interface RewardEdgePromise extends Promise<RewardEdge>, Fragmentable {
  node: <T = RewardPromise>() => T;
  cursor: () => Promise<string>;
}

export interface RewardEdgeSubscription
  extends Promise<AsyncIterator<RewardEdge>>,
    Fragmentable {
  node: <T = RewardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export interface AggregateSlashing {
  count: Int;
}

export interface AggregateSlashingPromise
  extends Promise<AggregateSlashing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSlashingSubscription
  extends Promise<AsyncIterator<AggregateSlashing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTotalIssuance {
  count: Int;
}

export interface AggregateTotalIssuancePromise
  extends Promise<AggregateTotalIssuance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTotalIssuanceSubscription
  extends Promise<AsyncIterator<AggregateTotalIssuance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NominationEdge {
  node: Nomination;
  cursor: string;
}

export interface NominationEdgePromise
  extends Promise<NominationEdge>,
    Fragmentable {
  node: <T = NominationPromise>() => T;
  cursor: () => Promise<string>;
}

export interface NominationEdgeSubscription
  extends Promise<AsyncIterator<NominationEdge>>,
    Fragmentable {
  node: <T = NominationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<string>>;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'HeartBeat',
    embedded: false,
  },
  {
    name: 'Reward',
    embedded: false,
  },
  {
    name: 'Slashing',
    embedded: false,
  },
  {
    name: 'Nomination',
    embedded: false,
  },
  {
    name: 'Stake',
    embedded: false,
  },
  {
    name: 'Validation',
    embedded: false,
  },
  {
    name: 'Session',
    embedded: false,
  },
  {
    name: 'TotalIssuance',
    embedded: false,
  },
  {
    name: 'BlockNumber',
    embedded: false,
  },
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`,
});
export const prisma = new Prisma();
