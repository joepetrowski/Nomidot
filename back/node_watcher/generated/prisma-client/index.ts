// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  blockNumber: (where?: BlockNumberWhereInput) => Promise<boolean>;
  imOnline: (where?: ImOnlineWhereInput) => Promise<boolean>;
  nominations: (where?: NominationsWhereInput) => Promise<boolean>;
  rewards: (where?: RewardsWhereInput) => Promise<boolean>;
  sessions: (where?: SessionsWhereInput) => Promise<boolean>;
  slashing: (where?: SlashingWhereInput) => Promise<boolean>;
  stake: (where?: StakeWhereInput) => Promise<boolean>;
  totalIssuance: (where?: TotalIssuanceWhereInput) => Promise<boolean>;
  validations: (where?: ValidationsWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  blockNumber: (
    where: BlockNumberWhereUniqueInput
  ) => BlockNumberNullablePromise;
  blockNumbers: (args?: {
    where?: BlockNumberWhereInput;
    orderBy?: BlockNumberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BlockNumber>;
  blockNumbersConnection: (args?: {
    where?: BlockNumberWhereInput;
    orderBy?: BlockNumberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlockNumberConnectionPromise;
  imOnline: (where: ImOnlineWhereUniqueInput) => ImOnlineNullablePromise;
  imOnlines: (args?: {
    where?: ImOnlineWhereInput;
    orderBy?: ImOnlineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ImOnline>;
  imOnlinesConnection: (args?: {
    where?: ImOnlineWhereInput;
    orderBy?: ImOnlineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImOnlineConnectionPromise;
  nominations: (
    where: NominationsWhereUniqueInput
  ) => NominationsNullablePromise;
  nominationses: (args?: {
    where?: NominationsWhereInput;
    orderBy?: NominationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Nominations>;
  nominationsesConnection: (args?: {
    where?: NominationsWhereInput;
    orderBy?: NominationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NominationsConnectionPromise;
  rewards: (where: RewardsWhereUniqueInput) => RewardsNullablePromise;
  rewardses: (args?: {
    where?: RewardsWhereInput;
    orderBy?: RewardsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Rewards>;
  rewardsesConnection: (args?: {
    where?: RewardsWhereInput;
    orderBy?: RewardsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RewardsConnectionPromise;
  sessions: (where: SessionsWhereUniqueInput) => SessionsNullablePromise;
  sessionses: (args?: {
    where?: SessionsWhereInput;
    orderBy?: SessionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Sessions>;
  sessionsesConnection: (args?: {
    where?: SessionsWhereInput;
    orderBy?: SessionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionsConnectionPromise;
  slashing: (where: SlashingWhereUniqueInput) => SlashingNullablePromise;
  slashings: (args?: {
    where?: SlashingWhereInput;
    orderBy?: SlashingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Slashing>;
  slashingsConnection: (args?: {
    where?: SlashingWhereInput;
    orderBy?: SlashingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SlashingConnectionPromise;
  stake: (where: StakeWhereUniqueInput) => StakeNullablePromise;
  stakes: (args?: {
    where?: StakeWhereInput;
    orderBy?: StakeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Stake>;
  stakesConnection: (args?: {
    where?: StakeWhereInput;
    orderBy?: StakeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StakeConnectionPromise;
  totalIssuance: (
    where: TotalIssuanceWhereUniqueInput
  ) => TotalIssuanceNullablePromise;
  totalIssuances: (args?: {
    where?: TotalIssuanceWhereInput;
    orderBy?: TotalIssuanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TotalIssuance>;
  totalIssuancesConnection: (args?: {
    where?: TotalIssuanceWhereInput;
    orderBy?: TotalIssuanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TotalIssuanceConnectionPromise;
  validations: (
    where: ValidationsWhereUniqueInput
  ) => ValidationsNullablePromise;
  validationses: (args?: {
    where?: ValidationsWhereInput;
    orderBy?: ValidationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Validations>;
  validationsesConnection: (args?: {
    where?: ValidationsWhereInput;
    orderBy?: ValidationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ValidationsConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBlockNumber: (data: BlockNumberCreateInput) => BlockNumberPromise;
  updateBlockNumber: (args: {
    data: BlockNumberUpdateInput;
    where: BlockNumberWhereUniqueInput;
  }) => BlockNumberPromise;
  updateManyBlockNumbers: (args: {
    data: BlockNumberUpdateManyMutationInput;
    where?: BlockNumberWhereInput;
  }) => BatchPayloadPromise;
  upsertBlockNumber: (args: {
    where: BlockNumberWhereUniqueInput;
    create: BlockNumberCreateInput;
    update: BlockNumberUpdateInput;
  }) => BlockNumberPromise;
  deleteBlockNumber: (where: BlockNumberWhereUniqueInput) => BlockNumberPromise;
  deleteManyBlockNumbers: (
    where?: BlockNumberWhereInput
  ) => BatchPayloadPromise;
  createImOnline: (data: ImOnlineCreateInput) => ImOnlinePromise;
  updateImOnline: (args: {
    data: ImOnlineUpdateInput;
    where: ImOnlineWhereUniqueInput;
  }) => ImOnlinePromise;
  updateManyImOnlines: (args: {
    data: ImOnlineUpdateManyMutationInput;
    where?: ImOnlineWhereInput;
  }) => BatchPayloadPromise;
  upsertImOnline: (args: {
    where: ImOnlineWhereUniqueInput;
    create: ImOnlineCreateInput;
    update: ImOnlineUpdateInput;
  }) => ImOnlinePromise;
  deleteImOnline: (where: ImOnlineWhereUniqueInput) => ImOnlinePromise;
  deleteManyImOnlines: (where?: ImOnlineWhereInput) => BatchPayloadPromise;
  createNominations: (data: NominationsCreateInput) => NominationsPromise;
  updateNominations: (args: {
    data: NominationsUpdateInput;
    where: NominationsWhereUniqueInput;
  }) => NominationsPromise;
  updateManyNominationses: (args: {
    data: NominationsUpdateManyMutationInput;
    where?: NominationsWhereInput;
  }) => BatchPayloadPromise;
  upsertNominations: (args: {
    where: NominationsWhereUniqueInput;
    create: NominationsCreateInput;
    update: NominationsUpdateInput;
  }) => NominationsPromise;
  deleteNominations: (where: NominationsWhereUniqueInput) => NominationsPromise;
  deleteManyNominationses: (
    where?: NominationsWhereInput
  ) => BatchPayloadPromise;
  createRewards: (data: RewardsCreateInput) => RewardsPromise;
  updateRewards: (args: {
    data: RewardsUpdateInput;
    where: RewardsWhereUniqueInput;
  }) => RewardsPromise;
  updateManyRewardses: (args: {
    data: RewardsUpdateManyMutationInput;
    where?: RewardsWhereInput;
  }) => BatchPayloadPromise;
  upsertRewards: (args: {
    where: RewardsWhereUniqueInput;
    create: RewardsCreateInput;
    update: RewardsUpdateInput;
  }) => RewardsPromise;
  deleteRewards: (where: RewardsWhereUniqueInput) => RewardsPromise;
  deleteManyRewardses: (where?: RewardsWhereInput) => BatchPayloadPromise;
  createSessions: (data: SessionsCreateInput) => SessionsPromise;
  updateSessions: (args: {
    data: SessionsUpdateInput;
    where: SessionsWhereUniqueInput;
  }) => SessionsPromise;
  upsertSessions: (args: {
    where: SessionsWhereUniqueInput;
    create: SessionsCreateInput;
    update: SessionsUpdateInput;
  }) => SessionsPromise;
  deleteSessions: (where: SessionsWhereUniqueInput) => SessionsPromise;
  deleteManySessionses: (where?: SessionsWhereInput) => BatchPayloadPromise;
  createSlashing: (data: SlashingCreateInput) => SlashingPromise;
  updateSlashing: (args: {
    data: SlashingUpdateInput;
    where: SlashingWhereUniqueInput;
  }) => SlashingPromise;
  updateManySlashings: (args: {
    data: SlashingUpdateManyMutationInput;
    where?: SlashingWhereInput;
  }) => BatchPayloadPromise;
  upsertSlashing: (args: {
    where: SlashingWhereUniqueInput;
    create: SlashingCreateInput;
    update: SlashingUpdateInput;
  }) => SlashingPromise;
  deleteSlashing: (where: SlashingWhereUniqueInput) => SlashingPromise;
  deleteManySlashings: (where?: SlashingWhereInput) => BatchPayloadPromise;
  createStake: (data: StakeCreateInput) => StakePromise;
  updateStake: (args: {
    data: StakeUpdateInput;
    where: StakeWhereUniqueInput;
  }) => StakePromise;
  updateManyStakes: (args: {
    data: StakeUpdateManyMutationInput;
    where?: StakeWhereInput;
  }) => BatchPayloadPromise;
  upsertStake: (args: {
    where: StakeWhereUniqueInput;
    create: StakeCreateInput;
    update: StakeUpdateInput;
  }) => StakePromise;
  deleteStake: (where: StakeWhereUniqueInput) => StakePromise;
  deleteManyStakes: (where?: StakeWhereInput) => BatchPayloadPromise;
  createTotalIssuance: (data: TotalIssuanceCreateInput) => TotalIssuancePromise;
  updateTotalIssuance: (args: {
    data: TotalIssuanceUpdateInput;
    where: TotalIssuanceWhereUniqueInput;
  }) => TotalIssuancePromise;
  updateManyTotalIssuances: (args: {
    data: TotalIssuanceUpdateManyMutationInput;
    where?: TotalIssuanceWhereInput;
  }) => BatchPayloadPromise;
  upsertTotalIssuance: (args: {
    where: TotalIssuanceWhereUniqueInput;
    create: TotalIssuanceCreateInput;
    update: TotalIssuanceUpdateInput;
  }) => TotalIssuancePromise;
  deleteTotalIssuance: (
    where: TotalIssuanceWhereUniqueInput
  ) => TotalIssuancePromise;
  deleteManyTotalIssuances: (
    where?: TotalIssuanceWhereInput
  ) => BatchPayloadPromise;
  createValidations: (data: ValidationsCreateInput) => ValidationsPromise;
  updateValidations: (args: {
    data: ValidationsUpdateInput;
    where: ValidationsWhereUniqueInput;
  }) => ValidationsPromise;
  updateManyValidationses: (args: {
    data: ValidationsUpdateManyMutationInput;
    where?: ValidationsWhereInput;
  }) => BatchPayloadPromise;
  upsertValidations: (args: {
    where: ValidationsWhereUniqueInput;
    create: ValidationsCreateInput;
    update: ValidationsUpdateInput;
  }) => ValidationsPromise;
  deleteValidations: (where: ValidationsWhereUniqueInput) => ValidationsPromise;
  deleteManyValidationses: (
    where?: ValidationsWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  blockNumber: (
    where?: BlockNumberSubscriptionWhereInput
  ) => BlockNumberSubscriptionPayloadSubscription;
  imOnline: (
    where?: ImOnlineSubscriptionWhereInput
  ) => ImOnlineSubscriptionPayloadSubscription;
  nominations: (
    where?: NominationsSubscriptionWhereInput
  ) => NominationsSubscriptionPayloadSubscription;
  rewards: (
    where?: RewardsSubscriptionWhereInput
  ) => RewardsSubscriptionPayloadSubscription;
  sessions: (
    where?: SessionsSubscriptionWhereInput
  ) => SessionsSubscriptionPayloadSubscription;
  slashing: (
    where?: SlashingSubscriptionWhereInput
  ) => SlashingSubscriptionPayloadSubscription;
  stake: (
    where?: StakeSubscriptionWhereInput
  ) => StakeSubscriptionPayloadSubscription;
  totalIssuance: (
    where?: TotalIssuanceSubscriptionWhereInput
  ) => TotalIssuanceSubscriptionPayloadSubscription;
  validations: (
    where?: ValidationsSubscriptionWhereInput
  ) => ValidationsSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SlashingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "datetime_ASC"
  | "datetime_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ImOnlineOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sender_ASC"
  | "sender_DESC";

export type NominationsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "validator_controller_ASC"
  | "validator_controller_DESC"
  | "validator_stash_ASC"
  | "validator_stash_DESC"
  | "nominator_controller_ASC"
  | "nominator_controller_DESC"
  | "nominator_stash_ASC"
  | "nominator_stash_DESC"
  | "bonded_ASC"
  | "bonded_DESC";

export type RewardsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "datetime_ASC"
  | "datetime_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type SessionsOrderByInput = "id_ASC" | "id_DESC";

export type ValidationsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "validator_controller_ASC"
  | "validator_controller_DESC"
  | "validator_stash_ASC"
  | "validator_stash_DESC"
  | "validator_preferences_ASC"
  | "validator_preferences_DESC";

export type BlockNumberOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "number_ASC"
  | "number_DESC"
  | "authored_by_ASC"
  | "authored_by_DESC"
  | "start_datetime_ASC"
  | "start_datetime_DESC"
  | "hash_ASC"
  | "hash_DESC";

export type StakeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_stake_ASC"
  | "total_stake_DESC";

export type TotalIssuanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC";

export interface SessionsUpdateInput {
  start?: Maybe<BlockNumberUpdateOneRequiredInput>;
  end?: Maybe<BlockNumberUpdateOneRequiredInput>;
}

export interface ImOnlineCreateInput {
  id?: Maybe<ID_Input>;
  block_number: BlockNumberCreateOneInput;
  sender: String;
}

export interface SlashingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SlashingWhereInput>;
  AND?: Maybe<
    SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput
  >;
  OR?: Maybe<SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput>;
  NOT?: Maybe<
    SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput
  >;
}

export type BlockNumberWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  start_datetime?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
}>;

export interface RewardsCreaterecipientsInput {
  set?: Maybe<String[] | String>;
}

export type ImOnlineWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RewardsCreateInput {
  id?: Maybe<ID_Input>;
  datetime: DateTimeInput;
  amount: Int;
  authored_block: BlockNumberCreateOneInput;
  recipients?: Maybe<RewardsCreaterecipientsInput>;
}

export interface ImOnlineWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  block_number?: Maybe<BlockNumberWhereInput>;
  sender?: Maybe<String>;
  sender_not?: Maybe<String>;
  sender_in?: Maybe<String[] | String>;
  sender_not_in?: Maybe<String[] | String>;
  sender_lt?: Maybe<String>;
  sender_lte?: Maybe<String>;
  sender_gt?: Maybe<String>;
  sender_gte?: Maybe<String>;
  sender_contains?: Maybe<String>;
  sender_not_contains?: Maybe<String>;
  sender_starts_with?: Maybe<String>;
  sender_not_starts_with?: Maybe<String>;
  sender_ends_with?: Maybe<String>;
  sender_not_ends_with?: Maybe<String>;
  AND?: Maybe<ImOnlineWhereInput[] | ImOnlineWhereInput>;
  OR?: Maybe<ImOnlineWhereInput[] | ImOnlineWhereInput>;
  NOT?: Maybe<ImOnlineWhereInput[] | ImOnlineWhereInput>;
}

export interface NominationsUpdateManyMutationInput {
  validator_controller?: Maybe<String>;
  validator_stash?: Maybe<String>;
  nominator_controller?: Maybe<String>;
  nominator_stash?: Maybe<String>;
  bonded?: Maybe<Int>;
}

export interface ValidationsUpdateManyMutationInput {
  validator_controller?: Maybe<String>;
  validator_stash?: Maybe<String>;
  validator_preferences?: Maybe<Int>;
}

export type StakeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ValidationsCreateInput {
  id?: Maybe<ID_Input>;
  start: BlockNumberCreateOneInput;
  validator_controller: String;
  validator_stash: String;
  validator_preferences: Int;
}

export interface SessionsUpsertNestedInput {
  update: SessionsUpdateDataInput;
  create: SessionsCreateInput;
}

export interface TotalIssuanceUpdateManyMutationInput {
  amount?: Maybe<Int>;
}

export interface StakeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  block_number?: Maybe<BlockNumberWhereInput>;
  total_stake?: Maybe<Int>;
  total_stake_not?: Maybe<Int>;
  total_stake_in?: Maybe<Int[] | Int>;
  total_stake_not_in?: Maybe<Int[] | Int>;
  total_stake_lt?: Maybe<Int>;
  total_stake_lte?: Maybe<Int>;
  total_stake_gt?: Maybe<Int>;
  total_stake_gte?: Maybe<Int>;
  AND?: Maybe<StakeWhereInput[] | StakeWhereInput>;
  OR?: Maybe<StakeWhereInput[] | StakeWhereInput>;
  NOT?: Maybe<StakeWhereInput[] | StakeWhereInput>;
}

export interface NominationsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  validator_controller?: Maybe<String>;
  validator_controller_not?: Maybe<String>;
  validator_controller_in?: Maybe<String[] | String>;
  validator_controller_not_in?: Maybe<String[] | String>;
  validator_controller_lt?: Maybe<String>;
  validator_controller_lte?: Maybe<String>;
  validator_controller_gt?: Maybe<String>;
  validator_controller_gte?: Maybe<String>;
  validator_controller_contains?: Maybe<String>;
  validator_controller_not_contains?: Maybe<String>;
  validator_controller_starts_with?: Maybe<String>;
  validator_controller_not_starts_with?: Maybe<String>;
  validator_controller_ends_with?: Maybe<String>;
  validator_controller_not_ends_with?: Maybe<String>;
  validator_stash?: Maybe<String>;
  validator_stash_not?: Maybe<String>;
  validator_stash_in?: Maybe<String[] | String>;
  validator_stash_not_in?: Maybe<String[] | String>;
  validator_stash_lt?: Maybe<String>;
  validator_stash_lte?: Maybe<String>;
  validator_stash_gt?: Maybe<String>;
  validator_stash_gte?: Maybe<String>;
  validator_stash_contains?: Maybe<String>;
  validator_stash_not_contains?: Maybe<String>;
  validator_stash_starts_with?: Maybe<String>;
  validator_stash_not_starts_with?: Maybe<String>;
  validator_stash_ends_with?: Maybe<String>;
  validator_stash_not_ends_with?: Maybe<String>;
  nominator_controller?: Maybe<String>;
  nominator_controller_not?: Maybe<String>;
  nominator_controller_in?: Maybe<String[] | String>;
  nominator_controller_not_in?: Maybe<String[] | String>;
  nominator_controller_lt?: Maybe<String>;
  nominator_controller_lte?: Maybe<String>;
  nominator_controller_gt?: Maybe<String>;
  nominator_controller_gte?: Maybe<String>;
  nominator_controller_contains?: Maybe<String>;
  nominator_controller_not_contains?: Maybe<String>;
  nominator_controller_starts_with?: Maybe<String>;
  nominator_controller_not_starts_with?: Maybe<String>;
  nominator_controller_ends_with?: Maybe<String>;
  nominator_controller_not_ends_with?: Maybe<String>;
  nominator_stash?: Maybe<String>;
  nominator_stash_not?: Maybe<String>;
  nominator_stash_in?: Maybe<String[] | String>;
  nominator_stash_not_in?: Maybe<String[] | String>;
  nominator_stash_lt?: Maybe<String>;
  nominator_stash_lte?: Maybe<String>;
  nominator_stash_gt?: Maybe<String>;
  nominator_stash_gte?: Maybe<String>;
  nominator_stash_contains?: Maybe<String>;
  nominator_stash_not_contains?: Maybe<String>;
  nominator_stash_starts_with?: Maybe<String>;
  nominator_stash_not_starts_with?: Maybe<String>;
  nominator_stash_ends_with?: Maybe<String>;
  nominator_stash_not_ends_with?: Maybe<String>;
  session?: Maybe<SessionsWhereInput>;
  bonded?: Maybe<Int>;
  bonded_not?: Maybe<Int>;
  bonded_in?: Maybe<Int[] | Int>;
  bonded_not_in?: Maybe<Int[] | Int>;
  bonded_lt?: Maybe<Int>;
  bonded_lte?: Maybe<Int>;
  bonded_gt?: Maybe<Int>;
  bonded_gte?: Maybe<Int>;
  AND?: Maybe<NominationsWhereInput[] | NominationsWhereInput>;
  OR?: Maybe<NominationsWhereInput[] | NominationsWhereInput>;
  NOT?: Maybe<NominationsWhereInput[] | NominationsWhereInput>;
}

export interface BlockNumberWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  authored_by?: Maybe<String>;
  authored_by_not?: Maybe<String>;
  authored_by_in?: Maybe<String[] | String>;
  authored_by_not_in?: Maybe<String[] | String>;
  authored_by_lt?: Maybe<String>;
  authored_by_lte?: Maybe<String>;
  authored_by_gt?: Maybe<String>;
  authored_by_gte?: Maybe<String>;
  authored_by_contains?: Maybe<String>;
  authored_by_not_contains?: Maybe<String>;
  authored_by_starts_with?: Maybe<String>;
  authored_by_not_starts_with?: Maybe<String>;
  authored_by_ends_with?: Maybe<String>;
  authored_by_not_ends_with?: Maybe<String>;
  start_datetime?: Maybe<DateTimeInput>;
  start_datetime_not?: Maybe<DateTimeInput>;
  start_datetime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_datetime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_datetime_lt?: Maybe<DateTimeInput>;
  start_datetime_lte?: Maybe<DateTimeInput>;
  start_datetime_gt?: Maybe<DateTimeInput>;
  start_datetime_gte?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  AND?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
  OR?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
  NOT?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
}

export interface NominationsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NominationsWhereInput>;
  AND?: Maybe<
    NominationsSubscriptionWhereInput[] | NominationsSubscriptionWhereInput
  >;
  OR?: Maybe<
    NominationsSubscriptionWhereInput[] | NominationsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NominationsSubscriptionWhereInput[] | NominationsSubscriptionWhereInput
  >;
}

export interface SessionsUpdateDataInput {
  start?: Maybe<BlockNumberUpdateOneRequiredInput>;
  end?: Maybe<BlockNumberUpdateOneRequiredInput>;
}

export interface StakeUpdateManyMutationInput {
  total_stake?: Maybe<Int>;
}

export interface SessionsUpdateOneRequiredInput {
  create?: Maybe<SessionsCreateInput>;
  update?: Maybe<SessionsUpdateDataInput>;
  upsert?: Maybe<SessionsUpsertNestedInput>;
  connect?: Maybe<SessionsWhereUniqueInput>;
}

export type RewardsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NominationsUpdateInput {
  validator_controller?: Maybe<String>;
  validator_stash?: Maybe<String>;
  nominator_controller?: Maybe<String>;
  nominator_stash?: Maybe<String>;
  session?: Maybe<SessionsUpdateOneRequiredInput>;
  bonded?: Maybe<Int>;
}

export interface RewardsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  datetime?: Maybe<DateTimeInput>;
  datetime_not?: Maybe<DateTimeInput>;
  datetime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datetime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datetime_lt?: Maybe<DateTimeInput>;
  datetime_lte?: Maybe<DateTimeInput>;
  datetime_gt?: Maybe<DateTimeInput>;
  datetime_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  authored_block?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<RewardsWhereInput[] | RewardsWhereInput>;
  OR?: Maybe<RewardsWhereInput[] | RewardsWhereInput>;
  NOT?: Maybe<RewardsWhereInput[] | RewardsWhereInput>;
}

export type TotalIssuanceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SlashingUpdateManyMutationInput {
  datetime?: Maybe<DateTimeInput>;
  reason?: Maybe<String>;
  amount?: Maybe<Int>;
}

export interface SessionsCreateInput {
  id?: Maybe<ID_Input>;
  start: BlockNumberCreateOneInput;
  end: BlockNumberCreateOneInput;
}

export interface SlashingCreateInput {
  id?: Maybe<ID_Input>;
  block_number: BlockNumberCreateOneInput;
  datetime: DateTimeInput;
  reason: String;
  amount: Int;
}

export interface TotalIssuanceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
  OR?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
  NOT?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
}

export interface SessionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionsWhereInput>;
  AND?: Maybe<
    SessionsSubscriptionWhereInput[] | SessionsSubscriptionWhereInput
  >;
  OR?: Maybe<SessionsSubscriptionWhereInput[] | SessionsSubscriptionWhereInput>;
  NOT?: Maybe<
    SessionsSubscriptionWhereInput[] | SessionsSubscriptionWhereInput
  >;
}

export interface StakeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StakeWhereInput>;
  AND?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
  OR?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
  NOT?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
}

export interface RewardsUpdateManyMutationInput {
  datetime?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  recipients?: Maybe<RewardsUpdaterecipientsInput>;
}

export interface SessionsCreateOneInput {
  create?: Maybe<SessionsCreateInput>;
  connect?: Maybe<SessionsWhereUniqueInput>;
}

export type SlashingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NominationsCreateInput {
  id?: Maybe<ID_Input>;
  validator_controller: String;
  validator_stash: String;
  nominator_controller: String;
  nominator_stash: String;
  session: SessionsCreateOneInput;
  bonded: Int;
}

export interface SlashingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  block_number?: Maybe<BlockNumberWhereInput>;
  datetime?: Maybe<DateTimeInput>;
  datetime_not?: Maybe<DateTimeInput>;
  datetime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datetime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datetime_lt?: Maybe<DateTimeInput>;
  datetime_lte?: Maybe<DateTimeInput>;
  datetime_gt?: Maybe<DateTimeInput>;
  datetime_gte?: Maybe<DateTimeInput>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
  OR?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
  NOT?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
}

export interface ImOnlineUpdateManyMutationInput {
  sender?: Maybe<String>;
}

export interface ImOnlineSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImOnlineWhereInput>;
  AND?: Maybe<
    ImOnlineSubscriptionWhereInput[] | ImOnlineSubscriptionWhereInput
  >;
  OR?: Maybe<ImOnlineSubscriptionWhereInput[] | ImOnlineSubscriptionWhereInput>;
  NOT?: Maybe<
    ImOnlineSubscriptionWhereInput[] | ImOnlineSubscriptionWhereInput
  >;
}

export type ValidationsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NominationsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BlockNumberUpsertNestedInput {
  update: BlockNumberUpdateDataInput;
  create: BlockNumberCreateInput;
}

export interface SessionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  start?: Maybe<BlockNumberWhereInput>;
  end?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<SessionsWhereInput[] | SessionsWhereInput>;
  OR?: Maybe<SessionsWhereInput[] | SessionsWhereInput>;
  NOT?: Maybe<SessionsWhereInput[] | SessionsWhereInput>;
}

export interface ValidationsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  start?: Maybe<BlockNumberWhereInput>;
  validator_controller?: Maybe<String>;
  validator_controller_not?: Maybe<String>;
  validator_controller_in?: Maybe<String[] | String>;
  validator_controller_not_in?: Maybe<String[] | String>;
  validator_controller_lt?: Maybe<String>;
  validator_controller_lte?: Maybe<String>;
  validator_controller_gt?: Maybe<String>;
  validator_controller_gte?: Maybe<String>;
  validator_controller_contains?: Maybe<String>;
  validator_controller_not_contains?: Maybe<String>;
  validator_controller_starts_with?: Maybe<String>;
  validator_controller_not_starts_with?: Maybe<String>;
  validator_controller_ends_with?: Maybe<String>;
  validator_controller_not_ends_with?: Maybe<String>;
  validator_stash?: Maybe<String>;
  validator_stash_not?: Maybe<String>;
  validator_stash_in?: Maybe<String[] | String>;
  validator_stash_not_in?: Maybe<String[] | String>;
  validator_stash_lt?: Maybe<String>;
  validator_stash_lte?: Maybe<String>;
  validator_stash_gt?: Maybe<String>;
  validator_stash_gte?: Maybe<String>;
  validator_stash_contains?: Maybe<String>;
  validator_stash_not_contains?: Maybe<String>;
  validator_stash_starts_with?: Maybe<String>;
  validator_stash_not_starts_with?: Maybe<String>;
  validator_stash_ends_with?: Maybe<String>;
  validator_stash_not_ends_with?: Maybe<String>;
  validator_preferences?: Maybe<Int>;
  validator_preferences_not?: Maybe<Int>;
  validator_preferences_in?: Maybe<Int[] | Int>;
  validator_preferences_not_in?: Maybe<Int[] | Int>;
  validator_preferences_lt?: Maybe<Int>;
  validator_preferences_lte?: Maybe<Int>;
  validator_preferences_gt?: Maybe<Int>;
  validator_preferences_gte?: Maybe<Int>;
  AND?: Maybe<ValidationsWhereInput[] | ValidationsWhereInput>;
  OR?: Maybe<ValidationsWhereInput[] | ValidationsWhereInput>;
  NOT?: Maybe<ValidationsWhereInput[] | ValidationsWhereInput>;
}

export interface StakeUpdateInput {
  block_number?: Maybe<BlockNumberUpdateOneRequiredInput>;
  total_stake?: Maybe<Int>;
}

export interface TotalIssuanceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TotalIssuanceWhereInput>;
  AND?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
  OR?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
}

export interface RewardsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RewardsWhereInput>;
  AND?: Maybe<RewardsSubscriptionWhereInput[] | RewardsSubscriptionWhereInput>;
  OR?: Maybe<RewardsSubscriptionWhereInput[] | RewardsSubscriptionWhereInput>;
  NOT?: Maybe<RewardsSubscriptionWhereInput[] | RewardsSubscriptionWhereInput>;
}

export interface BlockNumberUpdateDataInput {
  number?: Maybe<Int>;
  authored_by?: Maybe<String>;
  start_datetime?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
}

export type SessionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BlockNumberUpdateOneRequiredInput {
  create?: Maybe<BlockNumberCreateInput>;
  update?: Maybe<BlockNumberUpdateDataInput>;
  upsert?: Maybe<BlockNumberUpsertNestedInput>;
  connect?: Maybe<BlockNumberWhereUniqueInput>;
}

export interface RewardsUpdaterecipientsInput {
  set?: Maybe<String[] | String>;
}

export interface ImOnlineUpdateInput {
  block_number?: Maybe<BlockNumberUpdateOneRequiredInput>;
  sender?: Maybe<String>;
}

export interface BlockNumberSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
  OR?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
}

export interface TotalIssuanceUpdateInput {
  amount?: Maybe<Int>;
}

export interface StakeCreateInput {
  id?: Maybe<ID_Input>;
  block_number: BlockNumberCreateOneInput;
  total_stake: Int;
}

export interface BlockNumberCreateOneInput {
  create?: Maybe<BlockNumberCreateInput>;
  connect?: Maybe<BlockNumberWhereUniqueInput>;
}

export interface BlockNumberUpdateManyMutationInput {
  number?: Maybe<Int>;
  authored_by?: Maybe<String>;
  start_datetime?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
}

export interface BlockNumberUpdateInput {
  number?: Maybe<Int>;
  authored_by?: Maybe<String>;
  start_datetime?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
}

export interface BlockNumberCreateInput {
  id?: Maybe<Int>;
  number: Int;
  authored_by: String;
  start_datetime: DateTimeInput;
  hash: String;
}

export interface SlashingUpdateInput {
  block_number?: Maybe<BlockNumberUpdateOneRequiredInput>;
  datetime?: Maybe<DateTimeInput>;
  reason?: Maybe<String>;
  amount?: Maybe<Int>;
}

export interface TotalIssuanceCreateInput {
  id?: Maybe<ID_Input>;
  amount: Int;
}

export interface ValidationsUpdateInput {
  start?: Maybe<BlockNumberUpdateOneRequiredInput>;
  validator_controller?: Maybe<String>;
  validator_stash?: Maybe<String>;
  validator_preferences?: Maybe<Int>;
}

export interface RewardsUpdateInput {
  datetime?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  authored_block?: Maybe<BlockNumberUpdateOneRequiredInput>;
  recipients?: Maybe<RewardsUpdaterecipientsInput>;
}

export interface ValidationsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ValidationsWhereInput>;
  AND?: Maybe<
    ValidationsSubscriptionWhereInput[] | ValidationsSubscriptionWhereInput
  >;
  OR?: Maybe<
    ValidationsSubscriptionWhereInput[] | ValidationsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ValidationsSubscriptionWhereInput[] | ValidationsSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AggregateValidations {
  count: Int;
}

export interface AggregateValidationsPromise
  extends Promise<AggregateValidations>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValidationsSubscription
  extends Promise<AsyncIterator<AggregateValidations>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateImOnline {
  count: Int;
}

export interface AggregateImOnlinePromise
  extends Promise<AggregateImOnline>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImOnlineSubscription
  extends Promise<AsyncIterator<AggregateImOnline>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValidationsPreviousValues {
  id: ID_Output;
  validator_controller: String;
  validator_stash: String;
  validator_preferences: Int;
}

export interface ValidationsPreviousValuesPromise
  extends Promise<ValidationsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  validator_controller: () => Promise<String>;
  validator_stash: () => Promise<String>;
  validator_preferences: () => Promise<Int>;
}

export interface ValidationsPreviousValuesSubscription
  extends Promise<AsyncIterator<ValidationsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  validator_controller: () => Promise<AsyncIterator<String>>;
  validator_stash: () => Promise<AsyncIterator<String>>;
  validator_preferences: () => Promise<AsyncIterator<Int>>;
}

export interface Nominations {
  id: ID_Output;
  validator_controller: String;
  validator_stash: String;
  nominator_controller: String;
  nominator_stash: String;
  bonded: Int;
}

export interface NominationsPromise extends Promise<Nominations>, Fragmentable {
  id: () => Promise<ID_Output>;
  validator_controller: () => Promise<String>;
  validator_stash: () => Promise<String>;
  nominator_controller: () => Promise<String>;
  nominator_stash: () => Promise<String>;
  session: <T = SessionsPromise>() => T;
  bonded: () => Promise<Int>;
}

export interface NominationsSubscription
  extends Promise<AsyncIterator<Nominations>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  validator_controller: () => Promise<AsyncIterator<String>>;
  validator_stash: () => Promise<AsyncIterator<String>>;
  nominator_controller: () => Promise<AsyncIterator<String>>;
  nominator_stash: () => Promise<AsyncIterator<String>>;
  session: <T = SessionsSubscription>() => T;
  bonded: () => Promise<AsyncIterator<Int>>;
}

export interface NominationsNullablePromise
  extends Promise<Nominations | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  validator_controller: () => Promise<String>;
  validator_stash: () => Promise<String>;
  nominator_controller: () => Promise<String>;
  nominator_stash: () => Promise<String>;
  session: <T = SessionsPromise>() => T;
  bonded: () => Promise<Int>;
}

export interface TotalIssuanceSubscriptionPayload {
  mutation: MutationType;
  node: TotalIssuance;
  updatedFields: String[];
  previousValues: TotalIssuancePreviousValues;
}

export interface TotalIssuanceSubscriptionPayloadPromise
  extends Promise<TotalIssuanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TotalIssuancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TotalIssuancePreviousValuesPromise>() => T;
}

export interface TotalIssuanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TotalIssuanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TotalIssuanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TotalIssuancePreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ImOnlineEdge {
  node: ImOnline;
  cursor: String;
}

export interface ImOnlineEdgePromise
  extends Promise<ImOnlineEdge>,
    Fragmentable {
  node: <T = ImOnlinePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImOnlineEdgeSubscription
  extends Promise<AsyncIterator<ImOnlineEdge>>,
    Fragmentable {
  node: <T = ImOnlineSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ValidationsEdge {
  node: Validations;
  cursor: String;
}

export interface ValidationsEdgePromise
  extends Promise<ValidationsEdge>,
    Fragmentable {
  node: <T = ValidationsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ValidationsEdgeSubscription
  extends Promise<AsyncIterator<ValidationsEdge>>,
    Fragmentable {
  node: <T = ValidationsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Validations {
  id: ID_Output;
  validator_controller: String;
  validator_stash: String;
  validator_preferences: Int;
}

export interface ValidationsPromise extends Promise<Validations>, Fragmentable {
  id: () => Promise<ID_Output>;
  start: <T = BlockNumberPromise>() => T;
  validator_controller: () => Promise<String>;
  validator_stash: () => Promise<String>;
  validator_preferences: () => Promise<Int>;
}

export interface ValidationsSubscription
  extends Promise<AsyncIterator<Validations>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: <T = BlockNumberSubscription>() => T;
  validator_controller: () => Promise<AsyncIterator<String>>;
  validator_stash: () => Promise<AsyncIterator<String>>;
  validator_preferences: () => Promise<AsyncIterator<Int>>;
}

export interface ValidationsNullablePromise
  extends Promise<Validations | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: <T = BlockNumberPromise>() => T;
  validator_controller: () => Promise<String>;
  validator_stash: () => Promise<String>;
  validator_preferences: () => Promise<Int>;
}

export interface ImOnlineConnection {
  pageInfo: PageInfo;
  edges: ImOnlineEdge[];
}

export interface ImOnlineConnectionPromise
  extends Promise<ImOnlineConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImOnlineEdge>>() => T;
  aggregate: <T = AggregateImOnlinePromise>() => T;
}

export interface ImOnlineConnectionSubscription
  extends Promise<AsyncIterator<ImOnlineConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImOnlineEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImOnlineSubscription>() => T;
}

export interface TotalIssuanceEdge {
  node: TotalIssuance;
  cursor: String;
}

export interface TotalIssuanceEdgePromise
  extends Promise<TotalIssuanceEdge>,
    Fragmentable {
  node: <T = TotalIssuancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TotalIssuanceEdgeSubscription
  extends Promise<AsyncIterator<TotalIssuanceEdge>>,
    Fragmentable {
  node: <T = TotalIssuanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImOnline {
  id: ID_Output;
  sender: String;
}

export interface ImOnlinePromise extends Promise<ImOnline>, Fragmentable {
  id: () => Promise<ID_Output>;
  block_number: <T = BlockNumberPromise>() => T;
  sender: () => Promise<String>;
}

export interface ImOnlineSubscription
  extends Promise<AsyncIterator<ImOnline>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  block_number: <T = BlockNumberSubscription>() => T;
  sender: () => Promise<AsyncIterator<String>>;
}

export interface ImOnlineNullablePromise
  extends Promise<ImOnline | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  block_number: <T = BlockNumberPromise>() => T;
  sender: () => Promise<String>;
}

export interface TotalIssuance {
  id: ID_Output;
  amount: Int;
}

export interface TotalIssuancePromise
  extends Promise<TotalIssuance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
}

export interface TotalIssuanceSubscription
  extends Promise<AsyncIterator<TotalIssuance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface TotalIssuanceNullablePromise
  extends Promise<TotalIssuance | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
}

export interface ValidationsSubscriptionPayload {
  mutation: MutationType;
  node: Validations;
  updatedFields: String[];
  previousValues: ValidationsPreviousValues;
}

export interface ValidationsSubscriptionPayloadPromise
  extends Promise<ValidationsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValidationsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ValidationsPreviousValuesPromise>() => T;
}

export interface ValidationsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValidationsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValidationsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ValidationsPreviousValuesSubscription>() => T;
}

export interface StakeEdge {
  node: Stake;
  cursor: String;
}

export interface StakeEdgePromise extends Promise<StakeEdge>, Fragmentable {
  node: <T = StakePromise>() => T;
  cursor: () => Promise<String>;
}

export interface StakeEdgeSubscription
  extends Promise<AsyncIterator<StakeEdge>>,
    Fragmentable {
  node: <T = StakeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BlockNumberSubscriptionPayload {
  mutation: MutationType;
  node: BlockNumber;
  updatedFields: String[];
  previousValues: BlockNumberPreviousValues;
}

export interface BlockNumberSubscriptionPayloadPromise
  extends Promise<BlockNumberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlockNumberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlockNumberPreviousValuesPromise>() => T;
}

export interface BlockNumberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlockNumberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlockNumberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlockNumberPreviousValuesSubscription>() => T;
}

export interface Stake {
  id: ID_Output;
  total_stake: Int;
}

export interface StakePromise extends Promise<Stake>, Fragmentable {
  id: () => Promise<ID_Output>;
  block_number: <T = BlockNumberPromise>() => T;
  total_stake: () => Promise<Int>;
}

export interface StakeSubscription
  extends Promise<AsyncIterator<Stake>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  block_number: <T = BlockNumberSubscription>() => T;
  total_stake: () => Promise<AsyncIterator<Int>>;
}

export interface StakeNullablePromise
  extends Promise<Stake | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  block_number: <T = BlockNumberPromise>() => T;
  total_stake: () => Promise<Int>;
}

export interface BlockNumberPreviousValues {
  id: Int;
  number: Int;
  authored_by: String;
  start_datetime: DateTimeOutput;
  hash: String;
}

export interface BlockNumberPreviousValuesPromise
  extends Promise<BlockNumberPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  number: () => Promise<Int>;
  authored_by: () => Promise<String>;
  start_datetime: () => Promise<DateTimeOutput>;
  hash: () => Promise<String>;
}

export interface BlockNumberPreviousValuesSubscription
  extends Promise<AsyncIterator<BlockNumberPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  number: () => Promise<AsyncIterator<Int>>;
  authored_by: () => Promise<AsyncIterator<String>>;
  start_datetime: () => Promise<AsyncIterator<DateTimeOutput>>;
  hash: () => Promise<AsyncIterator<String>>;
}

export interface SlashingEdge {
  node: Slashing;
  cursor: String;
}

export interface SlashingEdgePromise
  extends Promise<SlashingEdge>,
    Fragmentable {
  node: <T = SlashingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SlashingEdgeSubscription
  extends Promise<AsyncIterator<SlashingEdge>>,
    Fragmentable {
  node: <T = SlashingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBlockNumber {
  count: Int;
}

export interface AggregateBlockNumberPromise
  extends Promise<AggregateBlockNumber>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlockNumberSubscription
  extends Promise<AsyncIterator<AggregateBlockNumber>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Slashing {
  id: ID_Output;
  datetime: DateTimeOutput;
  reason: String;
  amount: Int;
}

export interface SlashingPromise extends Promise<Slashing>, Fragmentable {
  id: () => Promise<ID_Output>;
  block_number: <T = BlockNumberPromise>() => T;
  datetime: () => Promise<DateTimeOutput>;
  reason: () => Promise<String>;
  amount: () => Promise<Int>;
}

export interface SlashingSubscription
  extends Promise<AsyncIterator<Slashing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  block_number: <T = BlockNumberSubscription>() => T;
  datetime: () => Promise<AsyncIterator<DateTimeOutput>>;
  reason: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface SlashingNullablePromise
  extends Promise<Slashing | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  block_number: <T = BlockNumberPromise>() => T;
  datetime: () => Promise<DateTimeOutput>;
  reason: () => Promise<String>;
  amount: () => Promise<Int>;
}

export interface ImOnlineSubscriptionPayload {
  mutation: MutationType;
  node: ImOnline;
  updatedFields: String[];
  previousValues: ImOnlinePreviousValues;
}

export interface ImOnlineSubscriptionPayloadPromise
  extends Promise<ImOnlineSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImOnlinePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImOnlinePreviousValuesPromise>() => T;
}

export interface ImOnlineSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImOnlineSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImOnlineSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImOnlinePreviousValuesSubscription>() => T;
}

export interface SessionsEdge {
  node: Sessions;
  cursor: String;
}

export interface SessionsEdgePromise
  extends Promise<SessionsEdge>,
    Fragmentable {
  node: <T = SessionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionsEdgeSubscription
  extends Promise<AsyncIterator<SessionsEdge>>,
    Fragmentable {
  node: <T = SessionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImOnlinePreviousValues {
  id: ID_Output;
  sender: String;
}

export interface ImOnlinePreviousValuesPromise
  extends Promise<ImOnlinePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sender: () => Promise<String>;
}

export interface ImOnlinePreviousValuesSubscription
  extends Promise<AsyncIterator<ImOnlinePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sender: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRewards {
  count: Int;
}

export interface AggregateRewardsPromise
  extends Promise<AggregateRewards>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRewardsSubscription
  extends Promise<AsyncIterator<AggregateRewards>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockNumberEdge {
  node: BlockNumber;
  cursor: String;
}

export interface BlockNumberEdgePromise
  extends Promise<BlockNumberEdge>,
    Fragmentable {
  node: <T = BlockNumberPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlockNumberEdgeSubscription
  extends Promise<AsyncIterator<BlockNumberEdge>>,
    Fragmentable {
  node: <T = BlockNumberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RewardsConnection {
  pageInfo: PageInfo;
  edges: RewardsEdge[];
}

export interface RewardsConnectionPromise
  extends Promise<RewardsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RewardsEdge>>() => T;
  aggregate: <T = AggregateRewardsPromise>() => T;
}

export interface RewardsConnectionSubscription
  extends Promise<AsyncIterator<RewardsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RewardsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRewardsSubscription>() => T;
}

export interface NominationsSubscriptionPayload {
  mutation: MutationType;
  node: Nominations;
  updatedFields: String[];
  previousValues: NominationsPreviousValues;
}

export interface NominationsSubscriptionPayloadPromise
  extends Promise<NominationsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NominationsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NominationsPreviousValuesPromise>() => T;
}

export interface NominationsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NominationsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NominationsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NominationsPreviousValuesSubscription>() => T;
}

export interface AggregateNominations {
  count: Int;
}

export interface AggregateNominationsPromise
  extends Promise<AggregateNominations>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNominationsSubscription
  extends Promise<AsyncIterator<AggregateNominations>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NominationsPreviousValues {
  id: ID_Output;
  validator_controller: String;
  validator_stash: String;
  nominator_controller: String;
  nominator_stash: String;
  bonded: Int;
}

export interface NominationsPreviousValuesPromise
  extends Promise<NominationsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  validator_controller: () => Promise<String>;
  validator_stash: () => Promise<String>;
  nominator_controller: () => Promise<String>;
  nominator_stash: () => Promise<String>;
  bonded: () => Promise<Int>;
}

export interface NominationsPreviousValuesSubscription
  extends Promise<AsyncIterator<NominationsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  validator_controller: () => Promise<AsyncIterator<String>>;
  validator_stash: () => Promise<AsyncIterator<String>>;
  nominator_controller: () => Promise<AsyncIterator<String>>;
  nominator_stash: () => Promise<AsyncIterator<String>>;
  bonded: () => Promise<AsyncIterator<Int>>;
}

export interface NominationsConnection {
  pageInfo: PageInfo;
  edges: NominationsEdge[];
}

export interface NominationsConnectionPromise
  extends Promise<NominationsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NominationsEdge>>() => T;
  aggregate: <T = AggregateNominationsPromise>() => T;
}

export interface NominationsConnectionSubscription
  extends Promise<AsyncIterator<NominationsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NominationsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNominationsSubscription>() => T;
}

export interface TotalIssuancePreviousValues {
  id: ID_Output;
  amount: Int;
}

export interface TotalIssuancePreviousValuesPromise
  extends Promise<TotalIssuancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
}

export interface TotalIssuancePreviousValuesSubscription
  extends Promise<AsyncIterator<TotalIssuancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface ValidationsConnection {
  pageInfo: PageInfo;
  edges: ValidationsEdge[];
}

export interface ValidationsConnectionPromise
  extends Promise<ValidationsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValidationsEdge>>() => T;
  aggregate: <T = AggregateValidationsPromise>() => T;
}

export interface ValidationsConnectionSubscription
  extends Promise<AsyncIterator<ValidationsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ValidationsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateValidationsSubscription>() => T;
}

export interface RewardsSubscriptionPayload {
  mutation: MutationType;
  node: Rewards;
  updatedFields: String[];
  previousValues: RewardsPreviousValues;
}

export interface RewardsSubscriptionPayloadPromise
  extends Promise<RewardsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RewardsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RewardsPreviousValuesPromise>() => T;
}

export interface RewardsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RewardsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RewardsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RewardsPreviousValuesSubscription>() => T;
}

export interface TotalIssuanceConnection {
  pageInfo: PageInfo;
  edges: TotalIssuanceEdge[];
}

export interface TotalIssuanceConnectionPromise
  extends Promise<TotalIssuanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TotalIssuanceEdge>>() => T;
  aggregate: <T = AggregateTotalIssuancePromise>() => T;
}

export interface TotalIssuanceConnectionSubscription
  extends Promise<AsyncIterator<TotalIssuanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TotalIssuanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTotalIssuanceSubscription>() => T;
}

export interface RewardsPreviousValues {
  id: ID_Output;
  datetime: DateTimeOutput;
  amount: Int;
  recipients: String[];
}

export interface RewardsPreviousValuesPromise
  extends Promise<RewardsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datetime: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  recipients: () => Promise<String[]>;
}

export interface RewardsPreviousValuesSubscription
  extends Promise<AsyncIterator<RewardsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  datetime: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  recipients: () => Promise<AsyncIterator<String[]>>;
}

export interface StakeConnection {
  pageInfo: PageInfo;
  edges: StakeEdge[];
}

export interface StakeConnectionPromise
  extends Promise<StakeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StakeEdge>>() => T;
  aggregate: <T = AggregateStakePromise>() => T;
}

export interface StakeConnectionSubscription
  extends Promise<AsyncIterator<StakeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StakeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStakeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface SlashingConnection {
  pageInfo: PageInfo;
  edges: SlashingEdge[];
}

export interface SlashingConnectionPromise
  extends Promise<SlashingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SlashingEdge>>() => T;
  aggregate: <T = AggregateSlashingPromise>() => T;
}

export interface SlashingConnectionSubscription
  extends Promise<AsyncIterator<SlashingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SlashingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSlashingSubscription>() => T;
}

export interface SessionsSubscriptionPayload {
  mutation: MutationType;
  node: Sessions;
  updatedFields: String[];
  previousValues: SessionsPreviousValues;
}

export interface SessionsSubscriptionPayloadPromise
  extends Promise<SessionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionsPreviousValuesPromise>() => T;
}

export interface SessionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionsPreviousValuesSubscription>() => T;
}

export interface SessionsConnection {
  pageInfo: PageInfo;
  edges: SessionsEdge[];
}

export interface SessionsConnectionPromise
  extends Promise<SessionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionsEdge>>() => T;
  aggregate: <T = AggregateSessionsPromise>() => T;
}

export interface SessionsConnectionSubscription
  extends Promise<AsyncIterator<SessionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionsSubscription>() => T;
}

export interface SessionsPreviousValues {
  id: ID_Output;
}

export interface SessionsPreviousValuesPromise
  extends Promise<SessionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SessionsPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Rewards {
  id: ID_Output;
  datetime: DateTimeOutput;
  amount: Int;
  recipients: String[];
}

export interface RewardsPromise extends Promise<Rewards>, Fragmentable {
  id: () => Promise<ID_Output>;
  datetime: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  authored_block: <T = BlockNumberPromise>() => T;
  recipients: () => Promise<String[]>;
}

export interface RewardsSubscription
  extends Promise<AsyncIterator<Rewards>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  datetime: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  authored_block: <T = BlockNumberSubscription>() => T;
  recipients: () => Promise<AsyncIterator<String[]>>;
}

export interface RewardsNullablePromise
  extends Promise<Rewards | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datetime: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  authored_block: <T = BlockNumberPromise>() => T;
  recipients: () => Promise<String[]>;
}

export interface BlockNumberConnection {
  pageInfo: PageInfo;
  edges: BlockNumberEdge[];
}

export interface BlockNumberConnectionPromise
  extends Promise<BlockNumberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlockNumberEdge>>() => T;
  aggregate: <T = AggregateBlockNumberPromise>() => T;
}

export interface BlockNumberConnectionSubscription
  extends Promise<AsyncIterator<BlockNumberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlockNumberEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlockNumberSubscription>() => T;
}

export interface Sessions {
  id: ID_Output;
}

export interface SessionsPromise extends Promise<Sessions>, Fragmentable {
  id: () => Promise<ID_Output>;
  start: <T = BlockNumberPromise>() => T;
  end: <T = BlockNumberPromise>() => T;
}

export interface SessionsSubscription
  extends Promise<AsyncIterator<Sessions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: <T = BlockNumberSubscription>() => T;
  end: <T = BlockNumberSubscription>() => T;
}

export interface SessionsNullablePromise
  extends Promise<Sessions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: <T = BlockNumberPromise>() => T;
  end: <T = BlockNumberPromise>() => T;
}

export interface SlashingSubscriptionPayload {
  mutation: MutationType;
  node: Slashing;
  updatedFields: String[];
  previousValues: SlashingPreviousValues;
}

export interface SlashingSubscriptionPayloadPromise
  extends Promise<SlashingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SlashingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SlashingPreviousValuesPromise>() => T;
}

export interface SlashingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SlashingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SlashingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SlashingPreviousValuesSubscription>() => T;
}

export interface AggregateStake {
  count: Int;
}

export interface AggregateStakePromise
  extends Promise<AggregateStake>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStakeSubscription
  extends Promise<AsyncIterator<AggregateStake>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSessions {
  count: Int;
}

export interface AggregateSessionsPromise
  extends Promise<AggregateSessions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionsSubscription
  extends Promise<AsyncIterator<AggregateSessions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StakePreviousValues {
  id: ID_Output;
  total_stake: Int;
}

export interface StakePreviousValuesPromise
  extends Promise<StakePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total_stake: () => Promise<Int>;
}

export interface StakePreviousValuesSubscription
  extends Promise<AsyncIterator<StakePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total_stake: () => Promise<AsyncIterator<Int>>;
}

export interface StakeSubscriptionPayload {
  mutation: MutationType;
  node: Stake;
  updatedFields: String[];
  previousValues: StakePreviousValues;
}

export interface StakeSubscriptionPayloadPromise
  extends Promise<StakeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StakePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StakePreviousValuesPromise>() => T;
}

export interface StakeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StakeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StakeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StakePreviousValuesSubscription>() => T;
}

export interface BlockNumber {
  id: Int;
  number: Int;
  authored_by: String;
  start_datetime: DateTimeOutput;
  hash: String;
}

export interface BlockNumberPromise extends Promise<BlockNumber>, Fragmentable {
  id: () => Promise<Int>;
  number: () => Promise<Int>;
  authored_by: () => Promise<String>;
  start_datetime: () => Promise<DateTimeOutput>;
  hash: () => Promise<String>;
}

export interface BlockNumberSubscription
  extends Promise<AsyncIterator<BlockNumber>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  number: () => Promise<AsyncIterator<Int>>;
  authored_by: () => Promise<AsyncIterator<String>>;
  start_datetime: () => Promise<AsyncIterator<DateTimeOutput>>;
  hash: () => Promise<AsyncIterator<String>>;
}

export interface BlockNumberNullablePromise
  extends Promise<BlockNumber | null>,
    Fragmentable {
  id: () => Promise<Int>;
  number: () => Promise<Int>;
  authored_by: () => Promise<String>;
  start_datetime: () => Promise<DateTimeOutput>;
  hash: () => Promise<String>;
}

export interface SlashingPreviousValues {
  id: ID_Output;
  datetime: DateTimeOutput;
  reason: String;
  amount: Int;
}

export interface SlashingPreviousValuesPromise
  extends Promise<SlashingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datetime: () => Promise<DateTimeOutput>;
  reason: () => Promise<String>;
  amount: () => Promise<Int>;
}

export interface SlashingPreviousValuesSubscription
  extends Promise<AsyncIterator<SlashingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  datetime: () => Promise<AsyncIterator<DateTimeOutput>>;
  reason: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface RewardsEdge {
  node: Rewards;
  cursor: String;
}

export interface RewardsEdgePromise extends Promise<RewardsEdge>, Fragmentable {
  node: <T = RewardsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RewardsEdgeSubscription
  extends Promise<AsyncIterator<RewardsEdge>>,
    Fragmentable {
  node: <T = RewardsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSlashing {
  count: Int;
}

export interface AggregateSlashingPromise
  extends Promise<AggregateSlashing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSlashingSubscription
  extends Promise<AsyncIterator<AggregateSlashing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTotalIssuance {
  count: Int;
}

export interface AggregateTotalIssuancePromise
  extends Promise<AggregateTotalIssuance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTotalIssuanceSubscription
  extends Promise<AsyncIterator<AggregateTotalIssuance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NominationsEdge {
  node: Nominations;
  cursor: String;
}

export interface NominationsEdgePromise
  extends Promise<NominationsEdge>,
    Fragmentable {
  node: <T = NominationsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NominationsEdgeSubscription
  extends Promise<AsyncIterator<NominationsEdge>>,
    Fragmentable {
  node: <T = NominationsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "ImOnline",
    embedded: false
  },
  {
    name: "Rewards",
    embedded: false
  },
  {
    name: "Slashing",
    embedded: false
  },
  {
    name: "Nominations",
    embedded: false
  },
  {
    name: "Stake",
    embedded: false
  },
  {
    name: "Validations",
    embedded: false
  },
  {
    name: "Sessions",
    embedded: false
  },
  {
    name: "TotalIssuance",
    embedded: false
  },
  {
    name: "BlockNumber",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
